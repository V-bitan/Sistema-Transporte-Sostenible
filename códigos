import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]

for t in np.arange(0, tiempo_total, dt):
    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético y Desactivación Temporal')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético y Desactivación Temporal')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético y Desactivación Temporal')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Parámetros de la carretera (con polos magnéticos)
carretera_longitud = 100
magnetico_pos = np.array([50, 0])  # Posición del polo magnético

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Parámetros de dureza del método Brinell
fuerza_aplicada = 1000           # Fuerza aplicada en el método Brinell (Newtons)
diametro_bolita = 10             # Diámetro de la bolita de acero (mm)

# Parámetros del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria
fragilidad = 2.0                 # Escala arbitraria
maleabilidad = 6.0               # Escala arbitraria
ductilidad = 6.0                 # Escala arbitraria

# Parámetros de resistencia
resistencia_traccion = 8.0       # Escala arbitraria (Ej. acero)
resistencia_presion = 8.0        # Escala arbitraria (Ej. acero)
resistencia_choque = 7.0         # Escala arbitraria (Ej. acero)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 6.0                 # Escala arbitraria (Ej. cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 9.0               # Escala arbitraria (Ej. oro)
ductilidad = 6.0                 # Escala arbitraria (Ej. cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

# Convertir las posiciones en un array para graficar
posiciones = np.array(posiciones)

# Graficar la trayectoria del vehículo
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias = [energia_inicial]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias.append(energias[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias.append(energia_actual)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias = np.array(energias)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')

# Graficar la energía cinética del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias, label='Energía Cinética del Vehículo')
plt.xlabel('Tiempo (s)')
plt.ylabel('Energía Cinética (J)')
plt.legend()
plt.title('Conservación de la Energía Cinética del Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias.append(energias[-1])
            energia_calor.append(energia_calor[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias = np.array(energias)
energia_calor = np.array(energia_calor)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')

# Graficar la energía cinética del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')
plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')
plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')
plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (x, y)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
aceleracion = np.array([0, -9.8])  # Aceleración debido a la gravedad (m/s²)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial
magnetismo_repulsion = 1.0       # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 0.5                 # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 10:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X')
plt.ylabel('Posición Y')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')
plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo en sistema SI y C.G.S.
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')

plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Funciones para calcular áreas y volúmenes
def area_circulo(radio):
    return np.pi * radio**2

def area_triangulo(base, altura):
    return (base * altura) / 2

def area_rectangulo(longitud, ancho):
    return longitud * ancho

def area_cuadrado(lado):
    return lado**2

def volumen_esfera(radio):
    return (4/3) * np.pi * radio**3

def volumen_cilindro(radio, altura):
    return np.pi * radio**2 * altura

def volumen_cubo(lado):
    return lado**3

def volumen_prisma_rectangular(longitud, ancho, altura):
    return longitud * ancho * altura

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo

import numpy as np
import matplotlib.pyplot as plt

# Funciones para convertir entre grados y radianes
def grados_a_radianes(grados):
    return grados * np.pi / 180

def radianes_a_grados(radianes):
    return radianes * 180 / np.pi

# Funciones para calcular áreas y volúmenes
def area_circulo(radio):
    return np.pi * radio**2

def area_triangulo(base, altura):
    return (base * altura) / 2

def area_rectangulo(longitud, ancho):
    return longitud * ancho

def area_cuadrado(lado):
    return lado**2

def volumen_esfera(radio):
    return (4/3) * np.pi * radio**3

def volumen_cilindro(radio, altura):
    return np.pi * radio**2 * altura

def volumen_cubo(lado):
    return lado**3

def volumen_prisma_rectangular(longitud, ancho, altura):
    return longitud * ancho * altura

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Propiedades del material del vehículo
dureza = 7.0                     # Escala de Mohs (Ej. acero)
tenacidad = 5.0                  # Escala arbitraria (Ej. acero)
fragilidad = 2.0                 # Escala arbitraria (Ej. vidrio)
maleabilidad = 6.0               # Escala arbitraria (Ej. oro)
ductilidad = 9.0                 # Escala arbitraria (Ej. oro, cobre)

# Parámetros de resistencia
resistencia_traccion = 50        # Resistencia a la tracción del acero (kg/mm²)
resistencia_presion = 40         # Resistencia a la presión del acero (kg/mm²)
resistencia_choque = 45          # Resistencia al choque del acero (kg/mm²)

# Propiedades del gas en sistemas neumáticos
compresibilidad = 0.001          # Coeficiente de compresibilidad (arbitraria)
expansibilidad = 0.99            # Coeficiente de expansibilidad (arbitraria)

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Parámetros del dispositivo de medición de tiempo
boton_peligro_activado = False
tiempo_inicio = None
tiempo_fin = None

# Función para iniciar la medición del tiempo
def iniciar_medicion_tiempo(t):
    global boton_peligro_activado, tiempo_inicio
    boton_peligro_activado = True
    tiempo_inicio = t

# Función para detener la medición del tiempo
def detener_medicion_tiempo(t):
    global boton_peligro_activado, tiempo_fin
    boton_peligro_activado = False
    tiempo_fin = t
    tiempo_transcurrido = tiempo_fin - tiempo_inicio
    print(f"Tiempo transcurrido: {tiempo_transcurrido:.2f} segundos")

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular activación del botón de peligro en t=30 y desactivación en t=50
    if t == 30:
        iniciar_medicion_tiempo(t)
    elif t == 50:
        detener_medicion_tiempo(t)
    
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Interacción del Vehículo con el Sistema Magnético, Desactivación Temporal y Elasticidad (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')

plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)
magnetismo_repulsion = 1000      # Fuerza de repulsión magnética (N)
elasticidad = 0.8                # Coeficiente de elasticidad (0.0 a 1.0)
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Parámetros del dispositivo de medición de tiempo
boton_peligro_activado = False
tiempo_inicio = None
tiempo_fin = None

# Función para iniciar la medición del tiempo
def iniciar_medicion_tiempo(t):
    global boton_peligro_activado, tiempo_inicio
    boton_peligro_activado = True
    tiempo_inicio = t

# Función para detener la medición del tiempo
def detener_medicion_tiempo(t):
    global boton_peligro_activado, tiempo_fin
    boton_peligro_activado = False
    tiempo_fin = t
    tiempo_transcurrido = tiempo_fin - tiempo_inicio
    print(f"Tiempo transcurrido: {tiempo_transcurrido:.2f} segundos")

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

# Posición y velocidad de referencia para análisis relativo
referencia_pos = np.array([10, 0])  # Posición inicial de la referencia (m)
referencia_velocidad = np.array([1, 0])  # Velocidad de la referencia (m/s)

for t in np.arange(0, tiempo_total, dt):
    # Simular activación del botón de peligro en t=30 y desactivación en t=50
    if t == 30:
        iniciar_medicion_tiempo(t)
    elif t == 50:
        detener_medicion_tiempo(t)
    
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue

    # Calcular la distancia al polo magnético
    distancia = vehiculo_pos - magnetico_pos
    distancia_magnitud = np.linalg.norm(distancia)
    
    # Aplicar fuerza de repulsión magnética si el vehículo está cerca del polo magnético
    if distancia_magnitud < 1:
        repulsion = magnetismo_repulsion * distancia / distancia_magnitud**2
        vehiculo_pos = vehiculo_pos - elasticidad * repulsion  # Simular la recuperación elástica
        desactivado = True  # Desactivar el vehículo en situación de emergencia
    else:
        repulsion = np.array([0, 0])
    
    # Simular la influencia de la viscosidad y compresibilidad en el movimiento
    friccion = -viscosidad * velocidad
    velocidad += friccion * dt
    energia_perdida_por_calor += np.linalg.norm(friccion * velocidad * dt)
    
    # Actualizar la posición del vehículo
    vehiculo_pos = vehiculo_pos + velocidad * dt + repulsion * dt
    posiciones.append(vehiculo_pos)
    
    # Actualizar la posición y velocidad de la referencia
    referencia_pos = referencia_pos + referencia_velocidad * dt

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    
    # Simular la conversión de energía química (por ejemplo, combustión)
    if t > 20 and t < 30:
        energia_quimica_liberada = 5000  # Energía química liberada por combustión (J)
        energias_quimica.append(energia_quimica_liberada)
    else:
        energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo y la referencia
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.plot(np.arange(0, tiempo_total * dt, dt), np.full(int(tiempo_total / dt), referencia_pos[1]), label='Referencia en movimiento')
plt.scatter(magnetico_pos[0], magnetico_pos[1], color='red', label='Polo magnético')
plt.quiver(posiciones[:, 0], posiciones[:, 1], velocidad[0], velocidad[1], color='blue', label='Velocidad')  # Representar la velocidad como un vector
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de Movimiento y Reposo Relativos (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')

plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros del vehículo en sistema SI
vehiculo_pos = np.array([0, 0])  # Posición inicial del vehículo (m)
velocidad = np.array([1, 0])     # Velocidad inicial del vehículo (m/s)
masa_vehiculo = 1500             # Masa del vehículo (kg)
aceleracion = np.array([2, 1])   # Aceleración constante aplicada al vehículo (m/s²)
energia_inicial = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2  # Energía cinética inicial (J)

# Parámetros de resistencia y fuerzas
viscosidad = 50                  # Coeficiente de viscosidad (arbitraria)
energia_perdida_por_calor = 0    # Energía disipada en forma de calor (J)

# Parámetros del dispositivo de medición de tiempo
boton_peligro_activado = False
tiempo_inicio = None
tiempo_fin = None

# Función para iniciar la medición del tiempo
def iniciar_medicion_tiempo(t):
    global boton_peligro_activado, tiempo_inicio
    boton_peligro_activado = True
    tiempo_inicio = t

# Función para detener la medición del tiempo
def detener_medicion_tiempo(t):
    global boton_peligro_activado, tiempo_fin
    boton_peligro_activado = False
    tiempo_fin = t
    tiempo_transcurrido = tiempo_fin - tiempo_inicio
    print(f"Tiempo transcurrido: {tiempo_transcurrido:.2f} segundos")

# Simulación
tiempo_total = 100
dt = 0.1
posiciones = [vehiculo_pos]
energias_cinetica = [energia_inicial]
energia_calor = [energia_perdida_por_calor]
energias_quimica = [0]  # Suponemos que se inicia sin reacciones químicas importantes
desactivado = False
tiempo_desactivacion = 10  # segundos
contador_desactivacion = 0

for t in np.arange(0, tiempo_total, dt):
    # Simular activación del botón de peligro en t=30 y desactivación en t=50
    if t == 30:
        iniciar_medicion_tiempo(t)
    elif t == 50:
        detener_medicion_tiempo(t)
    
    # Simular desactivación temporal del vehículo
    if desactivado:
        contador_desactivacion += dt
        if contador_desactivacion >= tiempo_desactivacion:
            desactivado = False
            contador_desactivacion = 0
        else:
            posiciones.append(vehiculo_pos)
            energias_cinetica.append(energias_cinetica[-1])
            energia_calor.append(energia_calor[-1])
            energias_quimica.append(energias_quimica[-1])
            continue
    
    # Actualizar la velocidad y posición del vehículo bajo la acción de una fuerza constante
    velocidad += aceleracion * dt
    vehiculo_pos += velocidad * dt
    
    posiciones.append(vehiculo_pos)

    # Calcular la energía cinética actual
    energia_actual = 0.5 * masa_vehiculo * np.linalg.norm(velocidad)**2
    energias_cinetica.append(energia_actual)
    energia_calor.append(energia_perdida_por_calor)
    energias_quimica.append(0)

# Convertir las posiciones y energías en arrays para graficar
posiciones = np.array(posiciones)
energias_cinetica = np.array(energias_cinetica)
energia_calor = np.array(energia_calor)
energias_quimica = np.array(energias_quimica)

# Graficar la trayectoria del vehículo
plt.subplot(2, 1, 1)
plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del vehículo')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Trayectoria del Vehículo bajo Fuerza Constante (SI)')

# Graficar las energías del vehículo
plt.subplot(2, 1, 2)
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_cinetica, label='Energía Cinética del Vehículo')
plt.plot(np.arange(0, tiempo_total + dt, dt), energia_calor, label='Energía Perdida por Calor', linestyle='--')
plt.plot(np.arange(0, tiempo_total + dt, dt), energias_quimica, label='Energía Química Liberada', linestyle='-.')

plt.xlabel('Tiempo (s)')
plt.ylabel('Energía (J)')
plt.legend()
plt.title('Conservación y Transformación de la Energía en el Vehículo')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Funciones para calcular trayectorias
def movimiento_rectilineo(velocidad, tiempo):
    return velocidad * tiempo

def movimiento_curvilineo(velocidad, tiempo, radio):
    return radio * (1 - np.cos(velocidad * tiempo / radio))

def movimiento_circular(velocidad_angular, radio, tiempo):
    return radio * np.array([np.cos(velocidad_angular * tiempo), np.sin(velocidad_angular * tiempo)])

def movimiento_helicoidal(velocidad_lineal, velocidad_angular, radio, tiempo):
    return np.array([radio * np.cos(velocidad_angular * tiempo), radio * np.sin(velocidad_angular * tiempo), velocidad_lineal * tiempo])

def movimiento_parabolico(velocidad_inicial, angulo, tiempo, gravedad=9.81):
    angulo_rad = np.radians(angulo)
    x = velocidad_inicial * np.cos(angulo_rad) * tiempo
    y = velocidad_inicial * np.sin(angulo_rad) * tiempo - 0.5 * gravedad * tiempo**2
    return np.array([x, y])

# Parámetros de simulación
tiempo_total = 10
dt = 0.1
tiempos = np.arange(0, tiempo_total, dt)
velocidad_lineal = 2  # m/s
velocidad_angular = 0.2  # rad/s
radio = 5  # m
angulo_lanzamiento = 45  # grados

# Simular movimientos
trayectoria_rectilinea = [movimiento_rectilineo(velocidad_lineal, t) for t in tiempos]
trayectoria_curvilinea = [movimiento_curvilineo(velocidad_lineal, t, radio) for t in tiempos]
trayectoria_circular = [movimiento_circular(velocidad_angular, radio, t) for t in tiempos]
trayectoria_helicoidal = [movimiento_helicoidal(velocidad_lineal, velocidad_angular, radio, t) for t in tiempos]
trayectoria_parabolica = [movimiento_parabolico(velocidad_lineal, angulo_lanzamiento, t) for t in tiempos]

# Convertir trayectorias a arrays
trayectoria_circular = np.array(trayectoria_circular)
trayectoria_helicoidal = np.array(trayectoria_helicoidal)
trayectoria_parabolica = np.array(trayectoria_parabolica)

# Graficar las trayectorias
plt.figure(figsize=(12, 8))

# Movimiento Rectilíneo
plt.subplot(2, 3, 1)
plt.plot(tiempos, trayectoria_rectilinea, label='Rectilíneo')
plt.xlabel('Tiempo (s)')
plt.ylabel('Posición (m)')
plt.title('Movimiento Rectilíneo')
plt.legend()

# Movimiento Curvilíneo
plt.subplot(2, 3, 2)
plt.plot(tiempos, trayectoria_curvilinea, label='Curvilíneo')
plt.xlabel('Tiempo (s)')
plt.ylabel('Desplazamiento (m)')
plt.title('Movimiento Curvilíneo')
plt.legend()

# Movimiento Circular
plt.subplot(2, 3, 3)
plt.plot(trayectoria_circular[:, 0], trayectoria_circular[:, 1], label='Circular')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Movimiento Circular')
plt.legend()

# Movimiento Helicoidal
ax = plt.subplot(2, 3, 4, projection='3d')
ax.plot(trayectoria_helicoidal[:, 0], trayectoria_helicoidal[:, 1], trayectoria_helicoidal[:, 2], label='Helicoidal')
ax.set_xlabel('Posición X (m)')
ax.set_ylabel('Posición Y (m)')
ax.set_zlabel('Posición Z (m)')
ax.set_title('Movimiento Helicoidal')
plt.legend()

# Movimiento Parabólico
plt.subplot(2, 3, 5)
plt.plot(trayectoria_parabolica[:, 0], trayectoria_parabolica[:, 1], label='Parabólico')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Movimiento Parabólico')
plt.legend()

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        tiempos = np.arange(0, self.tiempo_total, self.dt)
        for t in tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title('Simulación de la Trayectoria del Cuerpo Móvil')
plt.show()
class SistemaFiltracion:
    def __init__(self, eficiencia):
        self.eficiencia = eficiencia

    def filtrar_emisiones(self, emisiones):
        emisiones_limpias = emisiones * (1 - self.eficiencia)
        return emisiones_limpias

# Parámetros del sistema de filtración
eficiencia_filtracion = 0.9  # 90% de eficiencia en filtración

# Crear y usar el sistema de filtración
sistema_filtracion = SistemaFiltracion(eficiencia_filtracion)
emisiones_producidas = 100  # Unidades arbitrarias de emisiones producidas
emisiones_limpias = sistema_filtracion.filtrar_emisiones(emisiones_producidas)

print(f"Emisiones Producidas: {emisiones_producidas} unidades")
print(f"Emisiones Limpias después de Filtración: {emisiones_limpias} unidades")

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil - Velocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil - Velocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica):
        self.fuerza_magnetica = fuerza_magnetica

    def aplicar_fuerza_magnetica(self, cuerpo):
        fuerza = np.array([self.fuerza_magnetica, 0])  # Fuerza aplicada en la dirección X
        cuerpo.aceleracion += fuerza / cuerpo.masa

# Parámetros del generador magnético
fuerza_magnetica = 500  # Newtons

# Crear el generador magnético y aplicar la fuerza magnética al cuerpo móvil
generador_magnetico = GeneradorMagnetico(fuerza_magnetica)
generador_magnetico.aplicar_fuerza_magnetica(cuerpo_movil)

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil - Velocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica):
        self.fuerza_magnetica = fuerza_magnetica

    def aplicar_fuerza_magnetica(self, cuerpo):
        fuerza = np.array([self.fuerza_magnetica, 0])  # Fuerza aplicada en la dirección X
        cuerpo.aceleracion += fuerza / cuerpo.masa

# Parámetros del generador magnético
fuerza_magnetica = 500  # Newtons

# Crear el generador magnético y aplicar la fuerza magnética al cuerpo móvil
generador_magnetico = GeneradorMagnetico(fuerza_magnetica)
generador_magnetico.aplicar_fuerza_magnetica(cuerpo_movil)
import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil - Velocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica):
        self.fuerza_magnetica = fuerza_magnetica

    def aplicar_fuerza_magnetica(self, cuerpo):
        fuerza = np.array([self.fuerza_magnetica, 0])  # Fuerza aplicada en la dirección X
        cuerpo.aceleracion += fuerza / cuerpo.masa

# Parámetros del generador magnético
fuerza_magnetica = 500  # Newtons

# Crear el generador magnético y aplicar la fuerza magnética al cuerpo móvil
generador_magnetico = GeneradorMagnetico(fuerza_magnetica)
generador_magnetico.aplicar_fuerza_magnetica(cuerpo_movil)
import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil - Velocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica):
        self.fuerza_magnetica = fuerza_magnetica

    def aplicar_fuerza_magnetica(self, cuerpo):
        fuerza = np.array([self.fuerza_magnetica, 0])  # Fuerza aplicada en la dirección X
        cuerpo.aceleracion += fuerza / cuerpo.masa

# Parámetros del generador magnético
fuerza_magnetica = 500  # Newtons

# Crear el generador magnético y aplicar la fuerza magnética al cuerpo móvil
generador_magnetico = GeneradorMagnetico(fuerza_magnetica)
generador_magnetico.aplicar_fuerza_magnetica(cuerpo_movil)

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil - Velocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica):
        self.fuerza_magnetica = fuerza_magnetica

    def aplicar_fuerza_magnetica(self, cuerpo):
        fuerza = np.array([self.fuerza_magnetica, 0])  # Fuerza aplicada en la dirección X
        cuerpo.aceleracion += fuerza / cuerpo.masa

# Parámetros del generador magnético
fuerza_magnetica = 500  # Newtons

# Crear el generador magnético y aplicar la fuerza magnética al cuerpo móvil
generador_magnetico = GeneradorMagnetico(fuerza_magnetica)
generador_magnetico.aplicar_fuerza_magnetica(cuerpo_movil)

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.tipo_movimiento = self.clasificar_movimiento()

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        elif np.all(self.aceleracion > 0):
            return "Movimiento Acelerado"
        elif np.all(self.aceleracion < 0):
            return "Movimiento Retardado"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    def calcular_aceleracion(self):
        variacion_velocidad = np.linalg.norm(self.velocidades[-1] - self.velocidades[0])
        tiempo_transcurrido = self.tiempos[-1]
        aceleracion = variacion_velocidad / tiempo_transcurrido
        return aceleracion

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil para diferentes escenarios
posicion_inicial = [0, 0]

# 1. Vehículo que inicia la marcha (Movimiento Acelerado)
velocidad_inicial_vehiculo = [0, 0]
aceleracion_vehiculo = [1, 0]
tiempo_total_vehiculo = 10

vehiculo = CuerpoMovil(posicion_inicial, velocidad_inicial_vehiculo, aceleracion_vehiculo, tiempo_total_vehiculo)
trayectoria_vehiculo = vehiculo.simular_movimiento()
aceleracion_vehiculo_calculada = vehiculo.calcular_aceleracion()

# 2. Cuerpo que cae libremente (Movimiento Acelerado)
velocidad_inicial_cuerpo = [0, 0]
aceleracion_cuerpo = [0, 9.81]  # Aceleración debido a la gravedad
tiempo_total_cuerpo = 10

cuerpo = CuerpoMovil(posicion_inicial, velocidad_inicial_cuerpo, aceleracion_cuerpo, tiempo_total_cuerpo)
trayectoria_cuerpo = cuerpo.simular_movimiento()
aceleracion_cuerpo_calculada = cuerpo.calcular_aceleracion()

# 3. Vehículo que se detiene (Movimiento Retardado)
velocidad_inicial_vehiculo_detenido = [10, 0]  # Velocidad inicial en m/s
aceleracion_vehiculo_detenido = [-1, 0]  # Aceleración negativa
tiempo_total_vehiculo_detenido = 10

vehiculo_detenido = CuerpoMovil(posicion_inicial, velocidad_inicial_vehiculo_detenido, aceleracion_vehiculo_detenido, tiempo_total_vehiculo_detenido)
trayectoria_vehiculo_detenido = vehiculo_detenido.simular_movimiento()
aceleracion_veh

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    def calcular_aceleracion(self):
        variacion_velocidad = self.velocidades[-1] - self.velocidades[0]
        tiempo_transcurrido = self.tiempos[-1]
        aceleracion = variacion_velocidad / tiempo_transcurrido
        return aceleracion

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
aceleracion = [2, 1]  # Aceleración constante (m/s²)
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)
aceleracion_calculada = cuerpo_movil.calcular_aceleracion()

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil\nVelocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s\nAceleración Calculada: {aceleracion_calculada}')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")
print(f"Aceleración Calculada: {aceleracion_calculada} m/s²")

import numpy as np
import matplotlib.pyplot as plt

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.masa = masa
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.fuerza_accion = self.masa * self.aceleracion

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def clasificar_movimiento(self):
        if np.all(self.aceleracion == 0):
            return "Movimiento Uniforme"
        else:
            return "Movimiento Variado"

    def simular_movimiento(self):
        for t in self.tiempos:
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_velocidad_media(self):
        espacio_recorrido = np.linalg.norm(self.posiciones[-1] - self.posiciones[0])
        tiempo_transcurrido = self.tiempos[-1]
        velocidad_media = espacio_recorrido / tiempo_transcurrido
        return velocidad_media

    def calcular_espacio_recorrido(self):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_transcurrido = self.tiempos[-1]
        espacio_recorrido = velocidad_media * tiempo_transcurrido
        return espacio_recorrido

    def calcular_tiempo_empleado(self, espacio):
        velocidad_media = self.calcular_velocidad_media()
        tiempo_empleado = espacio / velocidad_media
        return tiempo_empleado

    def calcular_aceleracion(self):
        variacion_velocidad = self.velocidades[-1] - self.velocidades[0]
        tiempo_transcurrido = self.tiempos[-1]
        aceleracion = variacion_velocidad / tiempo_transcurrido
        return aceleracion

    def calcular_fuerza_reaccion(self):
        return -self.fuerza_accion

    @staticmethod
    def convertir_kmh_a_cms(velocidad_kmh):
        return (velocidad_kmh * 100000) / 3600

# Parámetros del cuerpo móvil
posicion_inicial = [0, 0]
velocidad_inicial = [1, 0]
masa = 1500  # kg
aceleracion = [2, 1]  # m/s²
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total)
trayectoria = cuerpo_movil.simular_movimiento()
tipo_movimiento = cuerpo_movil.clasificar_movimiento()
velocidad_media = cuerpo_movil.calcular_velocidad_media()
espacio_recorrido = cuerpo_movil.calcular_espacio_recorrido()
tiempo_empleado = cuerpo_movil.calcular_tiempo_empleado(espacio_recorrido)
aceleracion_calculada = cuerpo_movil.calcular_aceleracion()
fuerza_reaccion = cuerpo_movil.calcular_fuerza_reaccion()

# Convertir velocidad de km/h a cm/s
velocidad_kmh = 5  # Ejemplo: una persona sana caminando a 5 km/h
velocidad_cms = CuerpoMovil.convertir_kmh_a_cms(velocidad_kmh)

# Graficar la trayectoria del cuerpo móvil
plt.plot(trayectoria[:, 0], trayectoria[:, 1], label=f'Trayectoria del Cuerpo Móvil ({tipo_movimiento})')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.legend()
plt.title(f'Simulación de la Trayectoria del Cuerpo Móvil\nVelocidad Media: {velocidad_media:.2f} m/s\nVelocidad de {velocidad_kmh} km/h = {velocidad_cms:.2f} cm/s\nAceleración Calculada: {aceleracion_calculada} m/s²')
plt.show()

print(f"Velocidad en km/h: {velocidad_kmh} km/h")
print(f"Velocidad en cm/s: {velocidad_cms:.2f} cm/s")
print(f"Espacio recorrido: {espacio_recorrido:.2f} m")
print(f"Tiempo empleado para recorrer {espacio_recorrido:.2f} m: {tiempo_empleado:.2f} s")
print(f"Aceleración Calculada: {aceleracion_calculada} m/s²")
print(f"Fuerza de Acción: {cuerpo_movil.fuerza_accion} N")
print(f"Fuerza de Reacción: {fuerza_reaccion} N")

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica):
        self.fuerza_magnetica = fuerza_magnetica

    def aplicar_fuerza_magnetica(self, cuerpo):
        fuerza = np.array([self.fuerza_magnetica, 0])  # Fuerza aplicada en la dirección X
        cuerpo.aceleracion += fuerza / cuerpo.masa

# Parámetros del generador magnético
fuerza_magnetica = 500  # Newtons

# Crear el generador magnético y aplicar la fuerza magnética al cuerpo móvil
generador_magnetico = GeneradorMagnetico(fuerza_magnetica)
generador_magnetico.aplicar_fuerza_magnetica(cuerpo_movil)

import numpy as np
import matplotlib.pyplot as plt

class Fuerza:
    def __init__(self, origen, direccion, intensidad):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.vector_fuerza = self.direccion * self.intensidad

    def aplicar_fuerza(self, cuerpo):
        cuerpo.aceleracion += self.vector_fuerza / cuerpo.masa

    def trasladar_fuerza(self, nuevo_origen):
        self.origen = np.array(nuevo_origen)

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

# Parámetros del cuerpo móvil
class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.masa = masa
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def simular_movimiento(self):
        for t in self.tiempos:
            for fuerza in self.fuerzas:
                fuerza.aplicar_fuerza(self)
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def representar_movimiento(self):
        posiciones = np.array(self.posiciones)
        plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del Cuerpo Móvil')
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.legend()
        plt.title('Simulación de Fuerzas y Movimiento del Cuerpo Móvil')
        plt.grid()
        plt.show()

# Parámetros del cuerpo móvil y fuerzas
posicion_inicial = [0, 0]
velocidad_inicial = [0, 0]
masa = 1500  # kg
aceleracion = [0, 0]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total)

# Crear y agregar fuerzas
fuerza1 = Fuerza(origen=posicion_inicial, direccion=[1, 0], intensidad=1000)  # Fuerza horizontal a la derecha
fuerza2 = Fuerza(origen=posicion_inicial, direccion=[0, -1], intensidad=500)  # Fuerza vertical hacia abajo

cuerpo_movil.agregar_fuerza(fuerza1)
cuerpo_movil.agregar_fuerza(fuerza2)

# Simular movimiento y representar fuerzas y movimiento
cuerpo_movil.simular_movimiento()
cuerpo_movil.representar_movimiento()

import numpy as np
import matplotlib.pyplot as plt

class Fuerza:
    def __init__(self, origen, direccion, intensidad, duracion=None):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.duracion = duracion  # Duración en segundos (None para fuerzas instantáneas)
        self.vector_fuerza = self.direccion * self.intensidad

    def aplicar_fuerza(self, cuerpo, tiempo_actual):
        if self.duracion is None or tiempo_actual <= self.duracion:
            cuerpo.aceleracion += self.vector_fuerza / cuerpo.masa

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

# Parámetros del cuerpo móvil
class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.masa = masa
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def simular_movimiento(self):
        for t in self.tiempos:
            for fuerza in self.fuerzas:
                fuerza.aplicar_fuerza(self, t)
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def representar_movimiento(self):
        posiciones = np.array(self.posiciones)
        plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del Cuerpo Móvil')
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.legend()
        plt.title('Simulación de Fuerzas y Movimiento del Cuerpo Móvil')
        plt.grid()
        plt.show()

# Parámetros del cuerpo móvil y fuerzas
posicion_inicial = [0, 0]
velocidad_inicial = [0, 0]
masa = 1500  # kg
aceleracion = [0, 0]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total)

# Crear y agregar fuerzas
fuerza_continua = Fuerza(origen=posicion_inicial, direccion=[1, 0], intensidad=1000, duracion=tiempo_total)  # Fuerza continua a la derecha
fuerza_instantanea = Fuerza(origen=posicion_inicial, direccion=[0, -1], intensidad=500, duracion=0.1)  # Fuerza instantánea hacia abajo

cuerpo_movil.agregar_fuerza(fuerza_continua)
cuerpo_movil.agregar_fuerza(fuerza_instantanea)

# Simular movimiento y representar fuerzas y movimiento
cuerpo_movil.simular_movimiento()
cuerpo_movil.representar_movimiento()

import numpy as np
import matplotlib.pyplot as plt

class Dinamometro:
    def __init__(self, constante_elastica):
        self.constante_elastica = constante_elastica

    def medir_fuerza(self, deformacion):
        return self.constante_elastica * deformacion

class Fuerza:
    def __init__(self, origen, direccion, intensidad, duracion=None):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.duracion = duracion  # Duración en segundos (None para fuerzas instantáneas)
        self.vector_fuerza = self.direccion * self.intensidad

    def aplicar_fuerza(self, cuerpo, tiempo_actual):
        if self.duracion is None or tiempo_actual <= self.duracion:
            cuerpo.aceleracion += self.vector_fuerza / cuerpo.masa

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

# Parámetros del cuerpo móvil
class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.masa = masa
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def simular_movimiento(self):
        for t in self.tiempos:
            for fuerza in self.fuerzas:
                fuerza.aplicar_fuerza(self, t)
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def calcular_trabajo(self, desplazamiento, angulo=0):
        fuerza_magnitud = np.linalg.norm(self.aceleracion * self.masa)
        trabajo = fuerza_magnitud * desplazamiento * np.cos(np.radians(angulo))
        return trabajo

    def representar_movimiento(self):
        posiciones = np.array(self.posiciones)
        plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del Cuerpo Móvil')
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.legend()
        plt.title('Simulación de Fuerzas y Movimiento del Cuerpo Móvil')
        plt.grid()
        plt.show()

# Parámetros del cuerpo móvil y fuerzas
posicion_inicial = [0, 0]
velocidad_inicial = [0, 0]
masa = 1500  # kg
aceleracion = [0, 0]
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total)

# Crear y agregar fuerzas
fuerza_continua = Fuerza(origen=posicion_inicial, direccion=[1, 0], intensidad=1000, duracion=tiempo_total)  # Fuerza continua a la derecha
fuerza_instantanea = Fuerza(origen=posicion_inicial, direccion=[0, -1], intensidad=500, duracion=0.1)  # Fuerza instantánea hacia abajo

cuerpo_movil.agregar_fuerza(fuerza_continua)
cuerpo_movil.agregar_fuerza(fuerza_instantanea)

# Simular movimiento y representar fuerzas y movimiento
cuerpo_movil.simular_movimiento()
cuerpo_movil.representar_movimiento()

# Medir fuerza con dinamómetro
dinamometro = Dinamometro(constante_elastica=200)  # Constante elástica k
deformacion = 0.05  # Deformación en metros
fuerza_medida = dinamometro.medir_fuerza(deformacion)

# Calcular trabajo realizado
desplazamiento = 10  # Desplazamiento en metros
trabajo_realizado = cuerpo_movil.calcular_trabajo(desplazamiento)

print(f"Fuerza medida con dinamómetro: {fuerza_medida} N")
print(f"Trabajo realizado: {trabajo_realizado} J")

import numpy as np
import matplotlib.pyplot as plt

class Dinamometro:
    def __init__(self, constante_elastica):
        self.constante_elastica = constante_elastica

    def medir_fuerza(self, deformacion):
        return self.constante_elastica * deformacion

class Fuerza:
    def __init__(self, origen, direccion, intensidad, duracion=None):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.duracion = duracion  # Duración en segundos (None para fuerzas instantáneas)
        self.vector_fuerza = self.direccion * self.intensidad

    def aplicar_fuerza(self, cuerpo, tiempo_actual):
        if self.duracion is None or tiempo_actual <= self.duracion:
            cuerpo.aceleracion += self.vector_fuerza / cuerpo.masa

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

# Parámetros del cuerpo móvil
class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.masa = masa
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def simular_movimiento(self):
        for t in self.tiempos:
            for fuerza in self.fuerzas:
                fuerza.aplicar_fuerza(self, t)
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def calcular_fuerza(self):
        return self.masa * self.aceleracion

    def representar_movimiento(self):
        posiciones = np.array(self.posiciones)
        plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del Cuerpo Móvil')
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.legend()
        plt.title('Simulación de Fuerzas y Movimiento del Cuerpo Móvil')
        plt.grid()
        plt.show()

# Parámetros del cuerpo móvil y fuerzas
posicion_inicial = [0, 0]
velocidad_inicial = [0, 0]
masa = 1500  # kg
aceleracion = [2, 1]  # m/s²
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total)

# Crear y agregar fuerzas
fuerza_continua = Fuerza(origen=posicion_inicial, direccion=[1, 0], intensidad=1000, duracion=tiempo_total)  # Fuerza continua a la derecha
fuerza_instantanea = Fuerza(origen=posicion_inicial, direccion=[0, -1], intensidad=500, duracion=0.1)  # Fuerza instantánea hacia abajo

cuerpo_movil.agregar_fuerza(fuerza_continua)
cuerpo_movil.agregar_fuerza(fuerza_instantanea)

# Simular movimiento y representar fuerzas y movimiento
cuerpo_movil.simular_movimiento()
cuerpo_movil.representar_movimiento()

# Medir fuerza con dinamómetro
dinamometro = Dinamometro(constante_elastica=200)  # Constante elástica k
deformacion = 0.05  # Deformación en metros
fuerza_medida = dinamometro.medir_fuerza(deformacion)

# Calcular fuerza aplicada
fuerza_aplicada = cuerpo_movil.calcular_fuerza()

# Calcular trabajo realizado
desplazamiento = 10  # Desplazamiento en metros
trabajo_realizado = cuerpo_movil.calcular_trabajo(desplazamiento)

# Conversión de unidades de fuerza
def convertir_fuerza_dinas_a_newtons(dinas):
    return dinas / 100000

def convertir_fuerza_newtons_a_kgf(newtons):
    return newtons / 9.81

fuerza_en_dinas = 100000  # Ejemplo: 100,000 dinas
fuerza_en_newtons = convertir_fuerza_dinas_a_newtons(fuerza_en_dinas)
fuerza_en_kgf = convertir_fuerza_newtons_a_kgf(fuerza_en_newtons)

print(f"Fuerza medida con dinamómetro: {fuerza_medida} N")
print(f"Fuerza aplicada calculada: {fuerza_aplicada} N")
print(f"Trabajo realizado: {trabajo_realizado} J")
print(f"Fuerza en dinas: {fuerza_en_dinas} dyn")
print(f"Fuerza en newtons: {fuerza_en_newtons} N")
print(f"Fuerza en kilopondios: {fuerza_en_kgf} kgf")

import numpy as np
import matplotlib.pyplot as plt

class SistemaDeFuerzas:
    def __init__(self):
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def fuerza_resultante(self):
        resultante = np.sum([fuerza.vector_fuerza for fuerza in self.fuerzas], axis=0)
        return resultante

    def representar_fuerzas(self):
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        resultante = self.fuerza_resultante()
        plt.quiver(0, 0, resultante[0], resultante[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Fuerza Resultante')
        plt.legend()

class Fuerza:
    def __init__(self, origen, direccion, intensidad, duracion=None):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.duracion = duracion  # Duración en segundos (None para fuerzas instantáneas)
        self.vector_fuerza = self.direccion * self.intensidad

    def aplicar_fuerza(self, cuerpo, tiempo_actual):
        if self.duracion is None or tiempo_actual <= self.duracion:
            cuerpo.aceleracion += self.vector_fuerza / cuerpo.masa

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

class CuerpoMovil:
    def __init__(self, posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total, dt=0.1):
        self.posicion_inicial = np.array(posicion_inicial)
        self.velocidad_inicial = np.array(velocidad_inicial)
        self.masa = masa
        self.aceleracion = np.array(aceleracion)
        self.tiempo_total = tiempo_total
        self.dt = dt
        self.posiciones = [self.posicion_inicial]
        self.velocidades = [self.velocidad_inicial]
        self.tiempos = np.arange(0, tiempo_total, dt)
        self.sistema_fuerzas = SistemaDeFuerzas()

    def agregar_fuerza(self, fuerza):
        self.sistema_fuerzas.agregar_fuerza(fuerza)

    def simular_movimiento(self):
        for t in self.tiempos:
            for fuerza in self.sistema_fuerzas.fuerzas:
                fuerza.aplicar_fuerza(self, t)
            nueva_posicion = self.calcular_posicion(t)
            self.posiciones.append(nueva_posicion)
            nueva_velocidad = self.velocidad_inicial + self.aceleracion * t
            self.velocidades.append(nueva_velocidad)
        return np.array(self.posiciones)

    def calcular_posicion(self, t):
        return self.posicion_inicial + self.velocidad_inicial * t + 0.5 * self.aceleracion * t**2

    def calcular_fuerza(self):
        return self.masa * self.aceleracion

    def representar_movimiento(self):
        posiciones = np.array(self.posiciones)
        plt.plot(posiciones[:, 0], posiciones[:, 1], label='Trayectoria del Cuerpo Móvil')
        self.sistema_fuerzas.representar_fuerzas()
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.legend()
        plt.title('Simulación de Sistema de Fuerzas y Movimiento del Cuerpo Móvil')
        plt.grid()
        plt.show()

# Parámetros del cuerpo móvil y fuerzas
posicion_inicial = [0, 0]
velocidad_inicial = [0, 0]
masa = 1500  # kg
aceleracion = [2, 1]  # m/s²
tiempo_total = 10

# Crear y simular el cuerpo móvil
cuerpo_movil = CuerpoMovil(posicion_inicial, velocidad_inicial, masa, aceleracion, tiempo_total)

# Crear y agregar fuerzas al sistema de fuerzas
fuerza1 = Fuerza(origen=posicion_inicial, direccion=[1, 0], intensidad=1000, duracion=tiempo_total)  # Fuerza continua a la derecha
fuerza2 = Fuerza(origen=posicion_inicial, direccion=[0, -1], intensidad=500, duracion=0.1)  # Fuerza instantánea hacia abajo

cuerpo_movil.agregar_fuerza(fuerza1)
cuerpo_movil.agregar_fuerza(fuerza2)

# Simular movimiento y representar sistema de fuerzas y movimiento
cuerpo_movil.simular_movimiento()
cuerpo_movil.representar_movimiento()

import numpy as np
import matplotlib.pyplot as plt

class SistemaDeFuerzas:
    def __init__(self):
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def fuerza_resultante(self):
        resultante = np.sum([fuerza.vector_fuerza for fuerza in self.fuerzas], axis=0)
        return resultante

    def representar_fuerzas(self):
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        resultante = self.fuerza_resultante()
        plt.quiver(0, 0, resultante[0], resultante[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Fuerza Resultante')
        plt.legend()

class Fuerza:
    def __init__(self, origen, direccion, intensidad, duracion=None):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.duracion = duracion  # Duración en segundos (None para fuerzas instantáneas)
        self.vector_fuerza = self.direccion * self.intensidad

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

# Convertir masa en kilogramos a newtons (1 kg ≈ 9.81 N)
def kg_a_newtons(kg):
    return kg * 9.81

# Parámetros de las fuerzas en kilogramos
fuerza1_kg = 10  # kg
fuerza2_kg = 15  # kg

# Convertir fuerzas a newtons
fuerza1_n = kg_a_newtons(fuerza1_kg)
fuerza2_n = kg_a_newtons(fuerza2_kg)

# Crear y agregar fuerzas al sistema de fuerzas
sistema_fuerzas = SistemaDeFuerzas()
fuerza1 = Fuerza(origen=[0, 0], direccion=[1, 0], intensidad=fuerza1_n)  # Fuerza a la derecha
fuerza2 = Fuerza(origen=[0, 0], direccion=[1, 0], intensidad=fuerza2_n)  # Fuerza a la derecha
sistema_fuerzas.agregar_fuerza(fuerza1)
sistema_fuerzas.agregar_fuerza(fuerza2)

# Representar las fuerzas y la fuerza resultante
plt.figure(figsize=(8, 6))
sistema_fuerzas.representar_fuerzas()
plt.xlim(-10, 50)
plt.ylim(-10, 10)
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Composición de Fuerzas Paralelas')
plt.grid()
plt.show()

# Comprobar fuerza resultante con dinamómetro
dinamometro = Dinamometro(constante_elastica=200)  # Constante elástica k
deformacion = (fuerza1_n + fuerza2_n) / dinamometro.constante_elastica
fuerza_resultante_medida = dinamometro.medir_fuerza(deformacion)

print(f"Fuerza 1: {fuerza1_n} N")
print(f"Fuerza 2: {fuerza2_n} N")
print(f"Fuerza Resultante (calculada): {fuerza1_n + fuerza2_n} N")
print(f"Fuerza Resultante (medida con dinamómetro): {fuerza_resultante_medida} N")

# Fuerza equilibrante en un cuerpo suspendido
peso_cuerpo = kg_a_newtons(25)  # Cuerpo de 25 kg suspendido
tension_cuerda = -peso_cuerpo   # La tensión de la cuerda anula el peso del cuerpo

print(f"Peso del cuerpo: {peso_cuerpo} N")
print(f"Tensión de la cuerda (fuerza equilibrante): {tension_cuerda} N")

import numpy as np
import matplotlib.pyplot as plt

class Fuerza:
    def __init__(self, origen, direccion, intensidad, duracion=None):
        self.origen = np.array(origen)
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.intensidad = intensidad
        self.duracion = duracion  # Duración en segundos (None para fuerzas instantáneas)
        self.vector_fuerza = self.direccion * self.intensidad

    def representar_fuerza(self):
        plt.quiver(self.origen[0], self.origen[1], self.vector_fuerza[0], self.vector_fuerza[1],
                   angles='xy', scale_units='xy', scale=1, color='red')
        plt.text(self.origen[0], self.origen[1], f'F={self.intensidad}N', color='red')

class SistemaDeFuerzas:
    def __init__(self):
        self.fuerzas = []

    def agregar_fuerza(self, fuerza):
        self.fuerzas.append(fuerza)

    def fuerza_resultante(self):
        resultante = np.sum([fuerza.vector_fuerza for fuerza in self.fuerzas], axis=0)
        return resultante

    def representar_fuerzas(self):
        for fuerza in self.fuerzas:
            fuerza.representar_fuerza()
        resultante = self.fuerza_resultante()
        plt.quiver(0, 0, resultante[0], resultante[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Fuerza Resultante')
        plt.legend()

    def representar_paralelogramo(self):
        if len(self.fuerzas) == 2:
            f1 = self.fuerzas[0].vector_fuerza
            f2 = self.fuerzas[1].vector_fuerza
            plt.quiver(0, 0, f1[0], f1[1], angles='xy', scale_units='xy', scale=1, color='green', linestyle='--')
            plt.quiver(0, 0, f2[0], f2[1], angles='xy', scale_units='xy', scale=1, color='green', linestyle='--')
            plt.quiver(f1[0], f1[1], f2[0], f2[1], angles='xy', scale_units='xy', scale=1, color='orange', linestyle='--')
            plt.quiver(f2[0], f2[1], f1[0], f1[1], angles='xy', scale_units='xy', scale=1, color='orange', linestyle='--')
            resultante = f1 + f2
            plt.quiver(0, 0, resultante[0], resultante[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Fuerza Resultante')
            plt.legend()

# Parámetros de las fuerzas
f1 = Fuerza(origen=[0, 0], direccion=[1, 0], intensidad=1000)  # Fuerza en dirección X positiva
f2 = Fuerza(origen=[0, 0], direccion=[0.5, np.sqrt(3)/2], intensidad=1000)  # Fuerza en dirección 60 grados

# Crear y agregar fuerzas al sistema de fuerzas
sistema_fuerzas = SistemaDeFuerzas()
sistema_fuerzas.agregar_fuerza(f1)
sistema_fuerzas.agregar_fuerza(f2)

# Representar las fuerzas y la fuerza resultante mediante el método del paralelogramo
plt.figure(figsize=(8, 6))
sistema_fuerzas.representar_fuerzas()
sistema_fuerzas.representar_paralelogramo()
plt.xlim(-10, 1100)
plt.ylim(-10, 1100)
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Composición de Fuerzas mediante el Método del Paralelogramo')
plt.grid()
plt.show()

# Varias fuerzas concurrentes
f3 = Fuerza(origen=[0, 0], direccion=[1, 1], intensidad=700)
f4 = Fuerza(origen=[0, 0], direccion=[-1, 1], intensidad=500)
sistema_fuerzas.agregar_fuerza(f3)
sistema_fuerzas.agregar_fuerza(f4)

# Representar varias fuerzas concurrentes
plt.figure(figsize=(8, 6))
sistema_fuerzas.representar_fuerzas()
plt.xlim(-10, 1100)
plt.ylim(-10, 1100)
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Composición de Varias Fuerzas Concurrentes')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class FuerzaGravitacional:
    def __init__(self, masa1, masa2, distancia):
        self.masa1 = masa1
        self.masa2 = masa2
        self.distancia = distancia
        self.G = 6.67430e-11  # Constante de gravitación universal en N·m²/kg²

    def calcular_fuerza(self):
        return self.G * (self.masa1 * self.masa2) / (self.distancia ** 2)

    def direccion_fuerza(self, pos1, pos2):
        direccion = np.array(pos2) - np.array(pos1)
        direccion_normalizada = direccion / np.linalg.norm(direccion)
        return direccion_normalizada

class Cuerpo:
    def __init__(self, masa, posicion):
        self.masa = masa
        self.posicion = np.array(posicion)

    def calcular_fuerza_gravitacional(self, otro_cuerpo):
        distancia = np.linalg.norm(otro_cuerpo.posicion - self.posicion)
        fuerza_gravitacional = FuerzaGravitacional(self.masa, otro_cuerpo.masa, distancia)
        fuerza = fuerza_gravitacional.calcular_fuerza()
        direccion = fuerza_gravitacional.direccion_fuerza(self.posicion, otro_cuerpo.posicion)
        return fuerza * direccion

# Ejemplo de cuerpos
masa_tierra = 5.972e24  # masa de la Tierra en kg
masa_objeto = 1000  # masa del objeto en kg
posicion_tierra = [0, 0]
posicion_objeto = [0, 6371e3]  # a 6371 km del centro de la Tierra (radio de la Tierra)

cuerpo_tierra = Cuerpo(masa=masa_tierra, posicion=posicion_tierra)
cuerpo_objeto = Cuerpo(masa=masa_objeto, posicion=posicion_objeto)

# Calcular la fuerza gravitacional entre la Tierra y el objeto
fuerza_gravitacional = cuerpo_objeto.calcular_fuerza_gravitacional(cuerpo_tierra)

print(f"Fuerza gravitacional: {fuerza_gravitacional} N")

# Representación gráfica de la plomada
plt.figure(figsize=(8, 6))
plt.quiver(posicion_objeto[0], posicion_objeto[1], fuerza_gravitacional[0], fuerza_gravitacional[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Fuerza de Gravedad')
plt.scatter(posicion_tierra[0], posicion_tierra[1], color='green', label='Centro de la Tierra')
plt.scatter(posicion_objeto[0], posicion_objeto[1], color='red', label='Objeto Suspendido')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Dirección de la Gravedad Usando una Plomada')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class Cuerpo:
    def __init__(self, masas, posiciones):
        self.masas = masas
        self.posiciones = np.array(posiciones)
        self.centro_de_gravedad = self.calcular_centro_de_gravedad()

    def calcular_centro_de_gravedad(self):
        masa_total = np.sum(self.masas)
        centro_de_gravedad = np.sum(self.masas[:, np.newaxis] * self.posiciones, axis=0) / masa_total
        return centro_de_gravedad

    def representar_centro_de_gravedad(self):
        plt.scatter(self.posiciones[:, 0], self.posiciones[:, 1], color='red', label='Puntos de Masa')
        plt.scatter(self.centro_de_gravedad[0], self.centro_de_gravedad[1], color='blue', label='Centro de Gravedad')
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.title('Centro de Gravedad del Cuerpo')
        plt.legend()
        plt.grid()
        plt.show()

# Ejemplo de cuerpos con masas y posiciones
masas = np.array([5, 10, 15])  # Masas en kg
posiciones = np.array([[0, 0], [1, 0], [0, 1]])  # Posiciones en metros

cuerpo = Cuerpo(masas, posiciones)

# Calcular y representar el centro de gravedad
centro_de_gravedad = cuerpo.calcular_centro_de_gravedad()
print(f"Centro de Gravedad: {centro_de_gravedad}")

# Representación gráfica del centro de gravedad
cuerpo.representar_centro_de_gravedad()

import numpy as np
import matplotlib.pyplot as plt

class Cuerpo:
    def __init__(self, posiciones):
        self.posiciones = np.array(posiciones)
        self.centro_de_gravedad = self.calcular_centro_de_gravedad()

    def calcular_centro_de_gravedad(self):
        masa_total = len(self.posiciones)  # Asumimos masas iguales para simplicidad
        centro_de_gravedad = np.mean(self.posiciones, axis=0)
        return centro_de_gravedad

    def determinar_centro_de_gravedad_por_suspension(self, puntos_suspension):
        # Determina las direcciones verticales
        verticales = []
        for punto in puntos_suspension:
            direccion_vertical = self.posiciones[punto] - [0, 0]
            verticales.append(direccion_vertical)

        # Encuentra el punto de intersección de las verticales
        A, B = verticales[0], verticales[1]
        G = (A + B) / 2  # Simplificación para la intersección

        return G

    def representar_centro_de_gravedad(self, puntos_suspension):
        plt.scatter(self.posiciones[:, 0], self.posiciones[:, 1], color='red', label='Puntos de Masa')
        plt.scatter(self.centro_de_gravedad[0], self.centro_de_gravedad[1], color='blue', label='Centro de Gravedad')
        
        # Representa las verticales desde los puntos de suspensión
        for punto in puntos_suspension:
            plt.plot([self.posiciones[punto][0], 0], [self.posiciones[punto][1], 0], 'g--')
        
        # Representa el punto de intersección G
        G = self.determinar_centro_de_gravedad_por_suspension(puntos_suspension)
        plt.scatter(G[0], G[1], color='purple', label='Intersección G')

        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.title('Determinación del Centro de Gravedad por Suspensión')
        plt.legend()
        plt.grid()
        plt.show()

# Ejemplo de cuerpo con posiciones
posiciones = np.array([[0, 0], [1, 0], [0, 1]])  # Posiciones en metros
puntos_suspension = [0, 1]  # Puntos de suspensión (índices de los puntos)

cuerpo = Cuerpo(posiciones)

# Calcular y representar el centro de gravedad
centro_de_gravedad = cuerpo.calcular_centro_de_gravedad()
print(f"Centro de Gravedad: {centro_de_gravedad}")

# Representación gráfica del centro de gravedad por suspensión
cuerpo.representar_centro_de_gravedad(puntos_suspension)

import numpy as np
import matplotlib.pyplot as plt

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica, radio):
        self.fuerza_magnetica = fuerza_magnetica
        self.radio = radio  # Radio de la cúpula imantada

    def producir_cupula_imantada(self, posicion_centro):
        theta = np.linspace(0, 2 * np.pi, 100)
        x = posicion_centro[0] + self.radio * np.cos(theta)
        y = posicion_centro[1] + self.radio * np.sin(theta)
        return x, y

class Cuerpo:
    def __init__(self, masa, posicion):
        self.masa = masa
        self.posicion = np.array(posicion)

    def calcular_fuerza_gravitacional(self, otro_cuerpo):
        distancia = np.linalg.norm(otro_cuerpo.posicion - self.posicion)
        fuerza_gravitacional = FuerzaGravitacional(self.masa, otro_cuerpo.masa, distancia)
        fuerza = fuerza_gravitacional.calcular_fuerza()
        direccion = fuerza_gravitacional.direccion_fuerza(self.posicion, otro_cuerpo.posicion)
        return fuerza * direccion

# Ejemplo de cuerpos y generador magnético
masa_tierra = 5.972e24  # masa de la Tierra en kg
masa_objeto = 1000  # masa del objeto en kg
posicion_tierra = [0, 0]
posicion_objeto = [0, 6371e3]  # a 6371 km del centro de la Tierra (radio de la Tierra)

cuerpo_tierra = Cuerpo(masa=masa_tierra, posicion=posicion_tierra)
cuerpo_objeto = Cuerpo(masa=masa_objeto, posicion=posicion_objeto)

# Crear generador magnético y producir cúpula imantada
generador_magnetico = GeneradorMagnetico(fuerza_magnetica=5000, radio=7000e3)
x, y = generador_magnetico.producir_cupula_imantada(posicion_centro=posicion_objeto)

# Calcular la fuerza gravitacional entre la Tierra y el objeto
fuerza_gravitacional = cuerpo_objeto.calcular_fuerza_gravitacional(cuerpo_tierra)

print(f"Fuerza gravitacional: {fuerza_gravitacional} N")

# Representación gráfica de la cúpula imantada y la plomada
plt.figure(figsize=(8, 6))
plt.quiver(posicion_objeto[0], posicion_objeto[1], fuerza_gravitacional[0], fuerza_gravitacional[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Fuerza de Gravedad')
plt.scatter(posicion_tierra[0], posicion_tierra[1], color='green', label='Centro de la Tierra')
plt.scatter(posicion_objeto[0], posicion_objeto[1], color='red', label='Objeto Suspendido')
plt.plot(x, y, 'magenta', label='Cúpula Imantada')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Cúpula Imantada y Dirección de la Gravedad')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class Equilibrio:
    def __init__(self, tipo, posicion_inicial):
        self.tipo = tipo
        self.posicion_inicial = posicion_inicial

    def verificar_equilibrio(self):
        if self.tipo == 'estable':
            return 'El cuerpo tiende a volver a su posición original.'
        elif self.tipo == 'inestable':
            return 'El cuerpo tiende a alejarse de su posición original.'
        elif self.tipo == 'indiferente':
            return 'El cuerpo permanece en su nueva posición.'
        else:
            return 'Tipo de equilibrio desconocido.'

    def representar_equilibrio(self):
        plt.scatter(self.posicion_inicial[0], self.posicion_inicial[1], color='blue', label=f'Equilibrio {self.tipo}')
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.title(f'Representación de Equilibrio {self.tipo.capitalize()}')
        plt.legend()
        plt.grid()
        plt.show()

class Fuerza:
    def __init__(self, magnitud, direccion):
        self.magnitud = magnitud
        self.direccion = np.array(direccion) / np.linalg.norm(direccion)
        self.vector_fuerza = self.magnitud * self.direccion

    def calcular_trabajo(self, desplazamiento, angulo=0):
        return self.magnitud * desplazamiento * np.cos(np.radians(angulo))

    def calcular_rozamiento(self, coeficiente_rozamiento, fuerza_normal):
        return coeficiente_rozamiento * fuerza_normal

# Ejemplos de equilibrio
equilibrio_estable = Equilibrio(tipo='estable', posicion_inicial=[0, 0])
equilibrio_inestable = Equilibrio(tipo='inestable', posicion_inicial=[1, 0])
equilibrio_indiferente = Equilibrio(tipo='indiferente', posicion_inicial=[2, 0])

print(equilibrio_estable.verificar_equilibrio())
print(equilibrio_inestable.verificar_equilibrio())
print(equilibrio_indiferente.verificar_equilibrio())

# Representación gráfica de los tipos de equilibrio
equilibrio_estable.representar_equilibrio()
equilibrio_inestable.representar_equilibrio()
equilibrio_indiferente.representar_equilibrio()

# Ejemplo de fuerzas y cálculo de trabajo y rozamiento
fuerza = Fuerza(magnitud=100, direccion=[1, 0])
trabajo_realizado = fuerza.calcular_trabajo(desplazamiento=10, angulo=0)
fuerza_rozamiento = fuerza.calcular_rozamiento(coeficiente_rozamiento=0.3, fuerza_normal=150)

print(f"Trabajo realizado: {trabajo_realizado} J")
print(f"Fuerza de rozamiento: {fuerza_rozamiento} N")

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches

class Cono:
    def __init__(self, altura, radio_base):
        self.altura = altura
        self.radio_base = radio_base

    def representar_cono(self, posicion, angulo, tipo_equilibrio):
        fig, ax = plt.subplots()
        
        # Representación del cono
        if tipo_equilibrio == 'estable':
            cono = patches.Polygon([(posicion[0], posicion[1]), 
                                    (posicion[0] + self.radio_base, posicion[1]), 
                                    (posicion[0], posicion[1] + self.altura)], closed=True, fill=None, edgecolor='blue')
        elif tipo_equilibrio == 'inestable':
            cono = patches.Polygon([(posicion[0], posicion[1] + self.altura), 
                                    (posicion[0] - self.radio_base, posicion[1]), 
                                    (posicion[0] + self.radio_base, posicion[1])], closed=True, fill=None, edgecolor='red')
        elif tipo_equilibrio == 'indiferente':
            cono = patches.Polygon([(posicion[0], posicion[1]), 
                                    (posicion[0] + self.radio_base, posicion[1] + self.altura / 2), 
                                    (posicion[0] - self.radio_base, posicion[1] + self.altura / 2)], closed=True, fill=None, edgecolor='green')
        
        ax.add_patch(cono)
        
        # Título según el tipo de equilibrio
        if tipo_equilibrio == 'estable':
            plt.title('Cono en Equilibrio Estable')
        elif tipo_equilibrio == 'inestable':
            plt.title('Cono en Equilibrio Inestable')
        elif tipo_equilibrio == 'indiferente':
            plt.title('Cono en Equilibrio Indiferente')
        
        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.xlim(-2, 2)
        plt.ylim(-1, 3)
        plt.grid()
        plt.show()

# Crear un cono
cono = Cono(altura=2, radio_base=1)

# Representar el cono en diferentes tipos de equilibrio
# Cono apoyado por su base (Equilibrio Estable)
cono.representar_cono(posicion=[0, 0], angulo=90, tipo_equilibrio='estable')

# Cono apoyado por su vértice (Equilibrio Inestable)
cono.representar_cono(posicion=[0, 0], angulo=90, tipo_equilibrio='inestable')

# Cono apoyado por su generatriz (Equilibrio Indiferente)
cono.representar_cono(posicion=[0, 0], angulo=0, tipo_equilibrio='indiferente')

import numpy as np
import matplotlib.pyplot as plt

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica, radio):
        self.fuerza_magnetica = fuerza_magnetica
        self.radio = radio  # Radio de la cúpula imantada

    def producir_cupula_imantada(self, posicion_centro):
        theta = np.linspace(0, 2 * np.pi, 100)
        x = posicion_centro[0] + self.radio * np.cos(theta)
        y = posicion_centro[1] + self.radio * np.sin(theta)
        return x, y

class Cilindro:
    def __init__(self, masa_madera, masa_plomo, posicion_plomo, radio, longitud):
        self.masa_madera = masa_madera
        self.masa_plomo = masa_plomo
        self.posicion_plomo = np.array(posicion_plomo)
        self.radio = radio
        self.longitud = longitud
        self.centro_de_gravedad = self.calcular_centro_de_gravedad()

    def calcular_centro_de_gravedad(self):
        masa_total = self.masa_madera + self.masa_plomo
        posicion_madera = np.array([0, 0])
        centro_de_gravedad = (self.masa_madera * posicion_madera + self.masa_plomo * self.posicion_plomo) / masa_total
        return centro_de_gravedad

    def representar_cilindro(self, posicion_cilindro, angulo_inclinacion):
        fig, ax = plt.subplots()
        
        # Representación del cilindro
        circle = plt.Circle((posicion_cilindro[0], posicion_cilindro[1]), self.radio, edgecolor='blue', fill=False)
        ax.add_artist(circle)
        
        # Representación del trozo de plomo
        plomo = plt.Circle((posicion_cilindro[0] + self.posicion_plomo[0], posicion_cilindro[1] + self.posicion_plomo[1]), 0.1, color='red')
        ax.add_artist(plomo)
        
        # Representación del centro de gravedad
        plt.scatter(self.centro_de_gravedad[0] + posicion_cilindro[0], self.centro_de_gravedad[1] + posicion_cilindro[1], color='green', label='Centro de Gravedad G')

        # Representación del plano inclinado
        inclinacion = plt.Line2D((posicion_cilindro[0] - 1, posicion_cilindro[0] + 1), 
                                 (posicion_cilindro[1] - 1 * np.tan(np.radians(angulo_inclinacion)), 
                                  posicion_cilindro[1] + 1 * np.tan(np.radians(angulo_inclinacion))), color='black', linestyle='--')
        ax.add_line(inclinacion)

        plt.xlabel('Posición X (m)')
        plt.ylabel('Posición Y (m)')
        plt.title('Cilindro con Centro de Gravedad Descentrado')
        plt.legend()
        plt.grid()
        plt.axis('equal')
        plt.show()

# Parámetros del cilindro
masa_madera = 5  # kg
masa_plomo = 2  # kg
posicion_plomo = [0.1, 0.1]  # metros
radio = 0.5  # metros
longitud = 1.0  # metros
angulo_inclinacion = 30  # grados

# Crear el cilindro y calcular el centro de gravedad
cilindro = Cilindro(masa_madera, masa_plomo, posicion_plomo, radio, longitud)
centro_de_gravedad = cilindro.calcular_centro_de_gravedad()
print(f"Centro de Gravedad: {centro_de_gravedad}")

# Representación gráfica del cilindro en un plano inclinado
cilindro.representar_cilindro(posicion_cilindro=[0, 0], angulo_inclinacion=angulo_inclinacion)

import numpy as np
import matplotlib.pyplot as plt

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica, radio):
        self.fuerza_magnetica = fuerza_magnetica
        self.radio = radio  # Radio de la cúpula imantada

    def producir_cupula_imantada(self, posicion_centro):
        theta = np.linspace(0, 2 * np.pi, 100)
        x = posicion_centro[0] + self.radio * np.cos(theta)
        y = posicion_centro[1] + self.radio * np.sin(theta)
        return x, y

    def estabilizar_vehiculo(self, estado_via):
        if estado_via == 'irregular':
            # Implementar lógica para estabilizar el vehículo en vías irregulares
            pass

class SistemaAsistenciaConductor:
    def __init__(self):
        self.alcoholimetro = False
        self.sensores_visibilidad = False
        self.sensores_superficie = False

    def verificar_alcoholimetro(self, nivel_alcohol):
        if nivel_alcohol > 0.05:  # Límite legal en muchas regiones
            self.alcoholimetro = True
            return "Nivel de alcohol detectado. Arranque del vehículo bloqueado."
        return "Nivel de alcohol seguro. Arranque del vehículo permitido."

    def monitorear_visibilidad(self, condiciones_visibilidad):
        if condiciones_visibilidad == 'mala':
            self.sensores_visibilidad = True
            return "Mala visibilidad detectada. Activando sistemas de asistencia."
        return "Visibilidad adecuada. Sistema de asistencia inactivo."

    def monitorear_superficie(self, estado_via):
        if estado_via == 'irregular':
            self.sensores_superficie = True
            return "Vía irregular detectada. Ajustando suspensión y velocidad."
        return "Vía en buen estado. Sistema de asistencia inactivo."

# Ejemplos de implementación
generador_magnetico = GeneradorMagnetico(fuerza_magnetica=5000, radio=10)
sistema_asistencia_conductor = SistemaAsistenciaConductor()

# Verificación de alcoholímetro
resultado_alcoholimetro = sistema_asistencia_conductor.verificar_alcoholimetro(nivel_alcohol=0.06)
print(resultado_alcoholimetro)

# Monitoreo de visibilidad
resultado_visibilidad = sistema_asistencia_conductor.monitorear_visibilidad(condiciones_visibilidad='mala')
print(resultado_visibilidad)

# Monitoreo de superficie de la vía
resultado_superficie = sistema_asistencia_conductor.monitorear_superficie(estado_via='irregular')
print(resultado_superficie)

# Representación gráfica de la cúpula imantada
x, y = generador_magnetico.producir_cupula_imantada(posicion_centro=[0, 0])
plt.figure(figsize=(8, 6))
plt.plot(x, y, 'magenta', label='Cúpula Imantada')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Cúpula Imantada para Mejorar Visibilidad y Seguridad')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica, radio):
        self.fuerza_magnetica = fuerza_magnetica
        self.radio = radio  # Radio de la cúpula imantada

    def producir_cupula_imantada(self, posicion_centro):
        theta = np.linspace(0, 2 * np.pi, 100)
        x = posicion_centro[0] + self.radio * np.cos(theta)
        y = posicion_centro[1] + self.radio * np.sin(theta)
        return x, y

    def calcular_fuerza_magnetica(self, masa, constante_magnetica):
        return constante_magnetica * masa

class Cuerpo:
    def __init__(self, masa, tipo):
        self.masa = masa
        self.tipo = tipo  # Tipo de cuerpo que afecta la constante magnética

    def calcular_peso(self):
        g = 9.81  # Aceleración debida a la gravedad en m/s²
        return self.masa * g

# Ejemplo de implementación
generador_magnetico = GeneradorMagnetico(fuerza_magnetica=5000, radio=10)
cuerpo1 = Cuerpo(masa=1000, tipo='hierro')
cuerpo2 = Cuerpo(masa=500, tipo='madera')

# Constantes magnéticas (ejemplo: valores arbitrarios para distintos tipos de cuerpos)
constante_magnetica_hierro = 1.5
constante_magnetica_madera = 0.5

# Calcular fuerzas magnéticas
fuerza_magnetica_cuerpo1 = generador_magnetico.calcular_fuerza_magnetica(cuerpo1.masa, constante_magnetica_hierro)
fuerza_magnetica_cuerpo2 = generador_magnetico.calcular_fuerza_magnetica(cuerpo2.masa, constante_magnetica_madera)

# Calcular pesos
peso_cuerpo1 = cuerpo1.calcular_peso()
peso_cuerpo2 = cuerpo2.calcular_peso()

print(f"Fuerza magnética sobre el cuerpo de hierro: {fuerza_magnetica_cuerpo1} N")
print(f"Fuerza magnética sobre el cuerpo de madera: {fuerza_magnetica_cuerpo2} N")
print(f"Peso del cuerpo de hierro: {peso_cuerpo1} N")
print(f"Peso del cuerpo de madera: {peso_cuerpo2} N")

# Representación gráfica de la cúpula imantada
x, y = generador_magnetico.producir_cupula_imantada(posicion_centro=[0, 0])
plt.figure(figsize=(8, 6))
plt.plot(x, y, 'magenta', label='Cúpula Imantada')
plt.scatter(0, 0, color='blue', label='Generador Magnético')
plt.scatter(0.5, 0.5, color='red', label='Cuerpo de Hierro')
plt.scatter(-0.5, -0.5, color='green', label='Cuerpo de Madera')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Cúpula Imantada y Fuerza Magnética')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica, radio):
        self.fuerza_magnetica = fuerza_magnetica
        self.radio = radio  # Radio de la cúpula imantada

    def producir_cupula_imantada(self, posicion_centro):
        theta = np.linspace(0, 2 * np.pi, 100)
        x = posicion_centro[0] + self.radio * np.cos(theta)
        y = posicion_centro[1] + self.radio * np.sin(theta)
        return x, y

class Cuerpo:
    def __init__(self, masa, tipo, ubicacion='superficie', latitud=0):
        self.masa = masa
        self.tipo = tipo  # Tipo de cuerpo que afecta la constante magnética
        self.ubicacion = ubicacion  # 'superficie', 'ecuador', 'polo', 'altura'
        self.latitud = latitud  # Latitud en grados
        self.gravedad = self.calcular_gravedad()

    def calcular_gravedad(self):
        g = 9.81  # Aceleración debido a la gravedad en la superficie de la Tierra en m/s²
        if self.ubicacion == 'ecuador':
            g *= 0.997  # Ajuste aproximado para la gravedad en el ecuador
        elif self.ubicacion == 'polo':
            g *= 1.003  # Ajuste aproximado para la gravedad en el polo
        elif self.ubicacion == 'altura':
            g *= (1 - 2.256e-5 * self.latitud)  # Ajuste para altitud (aproximación)
        return g

    def calcular_peso(self):
        return self.masa * self.gravedad

# Ejemplo de implementación
generador_magnetico = GeneradorMagnetico(fuerza_magnetica=5000, radio=10)
cuerpo1 = Cuerpo(masa=1000, tipo='hierro', ubicacion='ecuador')
cuerpo2 = Cuerpo(masa=500, tipo='madera', ubicacion='polo')
cuerpo3 = Cuerpo(masa=700, tipo='plomo', ubicacion='altura', latitud=1000)  # 1000 metros de altitud

# Calcular pesos
peso_cuerpo1 = cuerpo1.calcular_peso()
peso_cuerpo2 = cuerpo2.calcular_peso()
peso_cuerpo3 = cuerpo3.calcular_peso()

print(f"Peso del cuerpo de hierro en el ecuador: {peso_cuerpo1} N")
print(f"Peso del cuerpo de madera en el polo: {peso_cuerpo2} N")
print(f"Peso del cuerpo de plomo a 1000 metros de altitud: {peso_cuerpo3} N")

# Representación gráfica de la cúpula imantada
x, y = generador_magnetico.producir_cupula_imantada(posicion_centro=[0, 0])
plt.figure(figsize=(8, 6))
plt.plot(x, y, 'magenta', label='Cúpula Imantada')
plt.scatter(0, 0, color='blue', label='Generador Magnético')
plt.scatter(0.5, 0.5, color='red', label='Cuerpo de Hierro (Ecuador)')
plt.scatter(-0.5, -0.5, color='green', label='Cuerpo de Madera (Polo)')
plt.scatter(0.7, -0.7, color='orange', label='Cuerpo de Plomo (Altitud)')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Cúpula Imantada y Fuerza Magnética')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class GeneradorMagnetico:
    def __init__(self, fuerza_magnetica, radio):
        self.fuerza_magnetica = fuerza_magnetica
        self.radio = radio  # Radio de la cúpula imantada

    def producir_cupula_imantada(self, posicion_centro):
        theta = np.linspace(0, 2 * np.pi, 100)
        x = posicion_centro[0] + self.radio * np.cos(theta)
        y = posicion_centro[1] + self.radio * np.sin(theta)
        return x, y

    def calcular_fuerza_magnetica(self, masa, constante_magnetica):
        return constante_magnetica * masa

class Cuerpo:
    def __init__(self, masa, tipo, ubicacion='superficie', latitud=0):
        self.masa = masa
        self.tipo = tipo  # Tipo de cuerpo que afecta la constante magnética
        self.ubicacion = ubicacion  # 'superficie', 'ecuador', 'polo', 'altura'
        self.latitud = latitud  # Latitud en grados
        self.gravedad = self.calcular_gravedad()

    def calcular_gravedad(self):
        g = 9.81  # Aceleración debido a la gravedad en la superficie de la Tierra en m/s²
        if self.ubicacion == 'ecuador':
            g *= 0.997  # Ajuste aproximado para la gravedad en el ecuador
        elif self.ubicacion == 'polo':
            g *= 1.003  # Ajuste aproximado para la gravedad en el polo
        elif self.ubicacion == 'altura':
            g *= (1 - 2.256e-5 * self.latitud)  # Ajuste para altitud (aproximación)
        return g

    def calcular_peso(self):
        return self.masa * self.gravedad

class SistemaAsistenciaConductor:
    def __init__(self):
        self.alcoholimetro = False
        self.sensores_visibilidad = False
        self.sensores_superficie = False

    def verificar_alcoholimetro(self, nivel_alcohol):
        if nivel_alcohol > 0.05:  # Límite legal en muchas regiones
            self.alcoholimetro = True
            return "Nivel de alcohol detectado. Arranque del vehículo bloqueado."
        return "Nivel de alcohol seguro. Arranque del vehículo permitido."

    def monitorear_visibilidad(self, condiciones_visibilidad):
        if condiciones_visibilidad == 'mala':
            self.sensores_visibilidad = True
            return "Mala visibilidad detectada. Activando sistemas de asistencia."
        return "Visibilidad adecuada. Sistema de asistencia inactivo."

    def monitorear_superficie(self, estado_via):
        if estado_via == 'irregular':
            self.sensores_superficie = True
            return "Vía irregular detectada. Ajustando suspensión y velocidad."
        return "Vía en buen estado. Sistema de asistencia inactivo."

# Ejemplos de implementación de funcionalidad
generador_magnetico = GeneradorMagnetico(fuerza_magnetica=5000, radio=10)
cuerpo1 = Cuerpo(masa=1000, tipo='hierro', ubicacion='ecuador')
cuerpo2 = Cuerpo(masa=500, tipo='madera', ubicacion='polo')
cuerpo3 = Cuerpo(masa=700, tipo='plomo', ubicacion='altura', latitud=1000)  # 1000 metros de altitud

# Calcular pesos
peso_cuerpo1 = cuerpo1.calcular_peso()
peso_cuerpo2 = cuerpo2.calcular_peso()
peso_cuerpo3 = cuerpo3.calcular_peso()

print(f"Peso del cuerpo de hierro en el ecuador: {peso_cuerpo1} N")
print(f"Peso del cuerpo de madera en el polo: {peso_cuerpo2} N")
print(f"Peso del cuerpo de plomo a 1000 metros de altitud: {peso_cuerpo3} N")

# Representación gráfica de la cúpula imantada
x, y = generador_magnetico.producir_cupula_imantada(posicion_centro=[0, 0])
plt.figure(figsize=(8, 6))
plt.plot(x, y, 'magenta', label='Cúpula Imantada')
plt.scatter(0, 0, color='blue', label='Generador Magnético')
plt.scatter(0.5, 0.5, color='red', label='Cuerpo de Hierro (Ecuador)')
plt.scatter(-0.5, -0.5, color='green', label='Cuerpo de Madera (Polo)')
plt.scatter(0.7, -0.7, color='orange', label='Cuerpo de Plomo (Altitud)')
plt.xlabel('Posición X (m)')
plt.ylabel('Posición Y (m)')
plt.title('Cúpula Imantada y Fuerza Magnética')
plt.legend()
plt.grid()
plt.show()

# Cálculo de la distancia recorrida por un auto
def calcular_distancia(velocidad, tiempo_minutos):
    tiempo_horas = tiempo_minutos / 60  # Conversión de minutos a horas
    distancia = velocidad * tiempo_horas  # Cálculo de la distancia
    return distancia

# Datos del problema
velocidad_auto = 70  # km/h
tiempo_viaje = 10  # minutos

# Cálculo de la distancia
distancia_recorrida = calcular_distancia(velocidad_auto, tiempo_viaje)

# Opciones de respuesta
opciones = {
    'A': 10,
    'B': 11.67,
    'C': 12,
    'D': 15
}

# Mostrar opciones y resultado
print("\nUn auto marcha a una velocidad de 70 kilómetros por hora.")
print("¿Qué distancia recorrerá en 10 minutos?")
for opcion, valor in opciones.items():
    print(f"{opcion}. {valor} km")

# Comprobación automática de la respuesta correcta
respuesta_correcta = 'B'
print(f"\nLa respuesta correcta es: {respuesta_correcta}. {opciones[respuesta_correcta]} km")

# Representación gráfica de la distancia recorrida
tiempos = np.linspace(0, tiempo_viaje, 100)
distancias = calcular_distancia(velocidad_auto, tiempos)

plt.figure(figsize=(10, 6))
plt.plot(tiempos, distancias, label='Distancia Recorrida')
plt.scatter([tiempo_viaje], [distancia_recorrida], color='red', label=f'Distancia en {tiempo_viaje} minutos: {distancia_recorrida:.2f} km')
plt.xlabel('Tiempo (minutos)')
plt.ylabel('Distancia (km)')
plt.title('Distancia Recorrida por un Auto en Movimiento')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Función para calcular la velocidad lineal
def calcular_velocidad_lineal(diametro_cm, rpm):
    radio_m = (diametro_cm / 2) / 100  # Conversión de centímetros a metros
    velocidad_angular = 2 * np.pi * rpm  # Velocidad angular en radianes por segundo
    velocidad_lineal = velocidad_angular * radio_m  # Velocidad lineal
    return velocidad_lineal

# Datos del problema
diametro_polea = 32  # cm
rpm_polea = 1  # Revoluciones por minuto (puede variar según el problema)

# Cálculo de la velocidad lineal
velocidad_lineal = calcular_velocidad_lineal(diametro_polea, rpm_polea)

# Opciones de respuesta
opciones = {
    'A': f"2π × {rpm_polea} × 0.1 m",
    'B': f"2π × {rpm_polea} × 0.16 m",
    'C': f"2π × {rpm_polea} × 0.2 m",
    'D': f"2π × {rpm_polea} × 0.32 m"
}

# Mostrar opciones y resultado
print("Una polea de 32 centímetros de diámetro gira dando vueltas por minuto.")
print("Calcular la velocidad de un punto situado en el borde de la polea.")
for opcion, valor in opciones.items():
    print(f"{opcion}. {valor}")

# Comprobación automática de la respuesta correcta
respuesta_correcta = 'B'
print(f"\nLa respuesta correcta es: {respuesta_correcta}. {opciones[respuesta_correcta]}")

# Representación gráfica de la velocidad lineal
rpm_values = np.linspace(0, 10, 100)  # RPM variando de 0 a 10
velocidades = calcular_velocidad_lineal(diametro_polea, rpm_values)

plt.figure(figsize=(10, 6))
plt.plot(rpm_values, velocidades, label='Velocidad Lineal')
plt.scatter([rpm_polea], [velocidad_lineal], color='red', label=f'Velocidad a {rpm_polea} RPM: {velocidad_lineal:.2f} m/s')
plt.xlabel('Revoluciones por Minuto (RPM)')
plt.ylabel('Velocidad Lineal (m/s)')
plt.title('Velocidad Lineal en el Borde de una Polea')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Función para calcular el encuentro de los autos
def calcular_encuentro(distancia_total, velocidad_auto1_kmh, velocidad_auto2_ms):
    velocidad_auto2_kmh = velocidad_auto2_ms * 18 / 5  # Conversión de m/s a km/h
    velocidad_relativa = velocidad_auto1_kmh + velocidad_auto2_kmh  # Velocidad relativa
    tiempo_encuentro = distancia_total / velocidad_relativa  # Tiempo para encontrarse en horas
    distancia_A = velocidad_auto1_kmh * tiempo_encuentro  # Distancia desde A
    distancia_B = velocidad_auto2_kmh * tiempo_encuentro  # Distancia desde B
    return tiempo_encuentro, distancia_A, distancia_B

# Datos del problema
distancia_total = 80  # km
velocidad_auto1 = 72  # km/h
velocidad_auto2 = 15  # m/s

# Cálculo del encuentro
tiempo_encuentro, distancia_A, distancia_B = calcular_encuentro(distancia_total, velocidad_auto1, velocidad_auto2)

# Opciones de respuesta
opciones = {
    'A': (0.6, 45, 35),
    'B': (0.635, 45.72, 34.29),
    'C': (0.65, 46, 34),
    'D': (0.7, 47, 33)
}

# Mostrar opciones y resultado
print("Dos poblaciones están a 80 km de distancia. Parte de A hacia B un auto con una velocidad de 72 km/h y, simultáneamente, parte de B hacia A otro auto con una velocidad de 15 m/s.")
print("Calcular cuánto tiempo tardarán en encontrarse, a qué distancia de A se encontrarán y, al terminar el viaje uno de ellos, qué distancia le faltará al otro y cuánto tiempo tardará todavía en llegar a su destino.")
for opcion, valores in opciones.items():
    print(f"{opcion}. Tiempo para encontrarse: {valores[0]} horas, Distancia desde A: {valores[1]} km, Distancia desde B: {valores[2]} km")

# Comprobación automática de la respuesta correcta
respuesta_correcta = 'B'
print(f"\nLa respuesta correcta es: {respuesta_correcta}. Tiempo para encontrarse: {opciones[respuesta_correcta][0]} horas, Distancia desde A: {opciones[respuesta_correcta][1]} km, Distancia desde B: {opciones[respuesta_correcta][2]} km")

# Calcular la distancia restante y tiempo para llegar al destino
distancia_restante_auto2 = distancia_total - distancia_A  # Distancia restante para el segundo auto
tiempo_restante_auto2 = distancia_restante_auto2 / (velocidad_auto2 * 18 / 5)  # Tiempo restante en horas

print(f"\nAl terminar el viaje del primer auto, la distancia restante para el segundo auto es: {distancia_restante_auto2} km")
print(f"El tiempo restante para que el segundo auto llegue a su destino es: {tiempo_restante_auto2:.2f} horas")

# Representación gráfica del encuentro
tiempos = np.linspace(0, tiempo_encuentro, 100)
distancia_auto1 = velocidad_auto1 * tiempos
distancia_auto2 = (velocidad_auto2 * 18 / 5) * tiempos

plt.figure(figsize=(10, 6))
plt.plot(tiempos, distancia_auto1, label='Distancia Recorrida por Auto 1 (A -> B)')
plt.plot(tiempos, distancia_auto2, label='Distancia Recorrida por Auto 2 (B -> A)')
plt.scatter([tiempo_encuentro], [distancia_A], color='red', label=f'Encuentro en {tiempo_encuentro:.3f} horas, a {distancia_A:.2f} km de A')
plt.xlabel('Tiempo (horas)')
plt.ylabel('Distancia (km)')
plt.title('Encuentro de Dos Autos')
plt.legend()
plt.grid()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Parámetros de simulación
tiempo_total = 10  # s
intervalos_tiempo = 100
tiempos = np.linspace(0, tiempo_total, intervalos_tiempo)
fuerza_aplicada = 5000  # N

# Resultados de simulación
posiciones = []
velocidades = []
aceleraciones = []

for t in tiempos:
    # Suponiendo resistencia constante
    aceleracion = (fuerza_aplicada - 500) / 1500  # masa = 1500 kg
    velocidad = aceleracion * t
    posicion = 0.5 * aceleracion * t ** 2
    aceleraciones.append(aceleracion)
    velocidades.append(velocidad)
    posiciones.append(posicion)

# Gráfico de resultados
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(tiempos, posiciones, label='Posición (m)')
plt.ylabel('Posición (m)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(tiempos, velocidades, label='Velocidad (m/s)', linestyle='--')
plt.ylabel('Velocidad (m/s)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(tiempos, aceleraciones, label='Aceleración (m/s²)', linestyle=':')
plt.xlabel('Tiempo (s)')
plt.ylabel('Aceleración (m/s²)')
plt.legend()

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Parámetros de simulación
gases_iniciales = 500  # unidades arbitrarias de gases contaminantes
intensidad_magnetica = 100  # unidades arbitrarias
eficiencia_purificacion = 0.9

# Resultados de simulación
gases_contaminantes = [gases_iniciales]
gases_purificados = [0]

for _ in range(10):
    capturados = min(gases_contaminantes[-1], intensidad_magnetica)
    purificados = capturados * eficiencia_purificacion
    gases_contaminantes.append(gases_contaminantes[-1] - capturados + (capturados - purificados))
    gases_purificados.append(gases_purificados[-1] + purificados)

# Gráfico de resultados
plt.figure(figsize=(12, 8))

plt.subplot(2, 1, 1)
plt.plot(range(11), gases_contaminantes, label='Gases Contaminantes')
plt.ylabel('Gases Contaminantes')
plt.legend()

plt.subplot(2, 1, 2)
plt.plot(range(11), gases_purificados, label='Gases Purificados', linestyle='--')
plt.xlabel('Iteraciones')
plt.ylabel('Gases Purificados')
plt.legend()

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Parámetros de la romana
C = 50  # Peso del cuerpo
d_C = 2  # Longitud del brazo corto
P = 10  # Peso del pilón
d_P = 10  # Longitud del brazo largo

# Función para graficar la romana
def graficar_romana(C, d_C, P, d_P):
    plt.figure(figsize=(10, 5))
    punto_apoyo = 0
    
    # Dibujar la romana
    plt.plot([punto_apoyo, -d_C], [0, 0], 'k-', lw=4)  # Barra hacia el cuerpo
    plt.plot([punto_apoyo, d_P], [0, 0], 'k-', lw=4)  # Barra hacia la pesa

    # Dibujar puntos de apoyo, cuerpo y pesa
    plt.plot(d_P, 0, 'ro', markersize=10, label='Punto de Pesa (P)')
    plt.plot(-d_C, 0, 'bo', markersize=10, label='Punto de Cuerpo (C)')
    plt.plot(punto_apoyo, 0, 'go', markersize=10, label='Punto de Apoyo (O)')

    # Dibujar líneas de fuerza
    plt.arrow(d_P, 0, 0, P, head_width=0.2, head_length=0.3, fc='r', ec='r')
    plt.arrow(-d_C, 0, 0, -C, head_width=0.2, head_length=0.3, fc='b', ec='b')

    # Añadir anotaciones
    plt.text(d_P, P + 0.1, 'P', fontsize=12, ha='center')
    plt.text(-d_C, -C - 0.4, 'C', fontsize=12, ha='center')
    plt.text(punto_apoyo, 0.1, 'O', fontsize=12, ha='center')

    # Configurar el gráfico
    plt.axhline(0, color='black', linewidth=0.5)
    plt.axvline(0, color='black', linewidth=0.5)
    plt.grid(color='gray', linestyle='--', linewidth=0.5)
    plt.xlim(-d_C - 1, d_P + 1)
    plt.ylim(-C - 1.5, P + 1.5)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.title('Romana como Palanca de Primer Género de Brazos Desiguales')
    plt.xlabel('Posición')
    plt.ylabel('Fuerza')
    plt.legend()
    plt.show()

# Graficar la romana
graficar_romana(C, d_C, P, d_P)
def actualizar_movimiento(self, tiempo):
    resistencia = self.calcular_resistencia()
    fuerza_neta = self.fuerza_aplicada - resistencia
    aceleracion = fuerza_neta / self.masa
    velocidad = aceleracion * tiempo
    posicion = 0.5 * aceleracion * tiempo ** 2
    return aceleracion, velocidad, posicion
def capturar_gases(self, cantidad_gases):
    capturados = min(cantidad_gases, self.intensidad_magnetica)
    self.gases_contaminantes += capturados
    return cantidad_gases - capturados

def purificar_gases(self):
    purificados = self.gases_contaminantes * 0.9  # asumiendo 90% de eficiencia
    self.gases_purificados += purificados
    self.gases_contaminantes -= purificados
def graficar_palanca(tipo, P, R, d_P, d_R, nombre):
    plt.figure(figsize=(10, 5))
    punto_apoyo = 0

    if tipo == 1:
        # Palanca de Primer Género: O entre P y R
        plt.plot([punto_apoyo, -d_R], [0, 0], 'k-', lw=4)  # Barra hacia resistencia
        plt.plot([punto_apoyo, d_P], [0, 0], 'k-', lw=4)  # Barra hacia potencia

    # Dibujar puntos de apoyo, potencia y resistencia
    plt.plot(d_P, 0, 'ro', markersize=10, label='Punto de Potencia (P)')
    plt.plot(-d_R, 0, 'bo', markersize=10, label='Punto de Resistencia (R)')
    plt.plot(punto_apoyo, 0, 'go', markersize=10, label='Punto de Apoyo (O)')

    # Dibujar líneas de fuerza
    plt.arrow(d_P, 0, 0, P, head_width=0.2, head_length=0.3, fc='r', ec='r')
    plt.arrow(-d_R, 0, 0, -R, head_width=0.2, head_length=0.3, fc='b', ec='b')

    # Añadir anotaciones
    plt.text(d_P, P + 0.1, 'P', fontsize=12, ha='center')
    plt.text(-d_R, -R - 0.4, 'R', fontsize=12, ha='center')
    plt.text(punto_apoyo, 0.1, 'O', fontsize=12, ha='center')

    plt.axhline(0, color='black', linewidth=0.5)
    plt.axvline(0, color='black', linewidth=0.5)
    plt.grid(color='gray', linestyle='--', linewidth=0.5)
    plt.xlim(-d_R - 1, d_P + 1)
    plt.ylim(-R - 1.5, P + 1.5)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.title(f'Palanca de {nombre}')
    plt.xlabel('Posición')
    plt.ylabel('Fuerza')
    plt.legend()
    plt.show()
def graficar_romana(C, d_C, P, d_P):
    plt.figure(figsize=(10, 5))
    punto_apoyo = 0
    
    plt.plot([punto_apoyo, -d_C], [0, 0], 'k-', lw=4)  # Barra hacia el cuerpo
    plt.plot([punto_apoyo, d_P], [0, 0], 'k-', lw=4)  # Barra hacia la pesa

    plt.plot(d_P, 0, 'ro', markersize=10, label='Punto de Pesa (P)')
    plt.plot(-d_C, 0, 'bo', markersize=10, label='Punto de Cuerpo (C)')
    plt.plot(punto_apoyo, 0, 'go', markersize=10, label='Punto de Apoyo (O)')

    plt.arrow(d_P, 0, 0, P, head_width=0.2, head_length=0.3, fc='r', ec='r')
    plt.arrow(-d_C, 0, 0, -C, head_width=0.2, head_length=0.3, fc='b', ec='b')

    plt.text(d_P, P + 0.1, 'P', fontsize=12, ha='center')
    plt.text(-d_C, -C - 0.4, 'C', fontsize=12, ha='center')
    plt.text(punto_apoyo, 0.1, 'O', fontsize=12, ha='center')

    plt.axhline(0, color='black', linewidth=0.5)
    plt.axvline(0, color='black', linewidth=0.5)
    plt.grid(color='gray', linestyle='--', linewidth=0.5)
    plt.xlim(-d_C - 1, d_P + 1)
    plt.ylim(-C - 1.5, P + 1.5)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.title('Romana como Palanca de Primer Género de Brazos Desiguales')
    plt.xlabel('Posición')
    plt.ylabel('Fuerza')
    plt.legend()
    plt.show()
import matplotlib.pyplot as plt

# Función para graficar la polea
def graficar_polea(tipo, radio, fuerza, titulo):
    plt.figure(figsize=(10, 5))
    centro = (0, 0)
    cuerda_x = [centro[0], centro[0] + radio]
    cuerda_y = [centro[1], centro[1]]
    
    # Dibujar la polea
    circulo = plt.Circle(centro, radio, color='gray', fill=False, linewidth=4)
    plt.gca().add_patch(circulo)
    
    if tipo == 'garganta':
        # Dibujar la cuerda en la garganta
        plt.plot(cuerda_x, cuerda_y, 'b-', lw=4, label='Cuerda')
    elif tipo == 'lisa':
        # Dibujar la correa lisa
        plt.plot(cuerda_x, cuerda_y, 'r-', lw=4, label='Correa')

    import numpy as np
import matplotlib.pyplot as plt

class Vehiculo:
    def __init__(self, masa, coef_arrastre, area_frontal):
        self.masa = masa
        self.coef_arrastre = coef_arrastre
        self.area_frontal = area_frontal
        self.velocidad = 0
        self.posicion = 0

    def calcular_resistencia(self, velocidad):
        densidad_aire = 1.225  # kg/m³
        resistencia_aerodinamica = 0.5 * densidad_aire * self.coef_arrastre * self.area_frontal * velocidad**2
        friccion = 0.01 * self.masa * 9.81  # Suponiendo un coeficiente de fricción de 0.01
        return resistencia_aerodinamica + friccion

    def actualizar_movimiento(self, fuerza, tiempo, delta_t):
        aceleraciones = []
        velocidades = []
        posiciones = []

        for t in np.arange(0, tiempo, delta_t):
            resistencia = self.calcular_resistencia(self.velocidad)
            aceleracion = (fuerza - resistencia) / self.masa
            self.velocidad += aceleracion * delta_t
            self.posicion += self.velocidad * delta_t

            aceleraciones.append(aceleracion)
            velocidades.append(self.velocidad)
            posiciones.append(self.posicion)

        return aceleraciones, velocidades, posiciones

# Parámetros del vehículo
masa = 1500  # kg
coef_arrastre = 0.3
area_frontal = 2.2  # m²
fuerza = 5000  # N
tiempo = 10  # s
delta_t = 0.1  # Intervalo de tiempo

vehiculo = Vehiculo(masa, coef_arrastre, area_frontal)
aceleraciones, velocidades, posiciones = vehiculo.actualizar_movimiento(fuerza, tiempo, delta_t)

# Gráfico de resultados
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(np.arange(0, tiempo, delta_t), posiciones, label='Posición (m)')
plt.ylabel('Posición (m)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(np.arange(0, tiempo, delta_t), velocidades, label='Velocidad (m/s)', linestyle='--')
plt.ylabel('Velocidad (m/s)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(np.arange(0, tiempo, delta_t), aceleraciones, label='Aceleración (m/s²)', linestyle=':')
plt.xlabel('Tiempo (s)')
plt.ylabel('Aceleración (m/s²)')
plt.legend()

plt.tight_layout()
plt.show()
class Sensor:
    def __init__(self, tipo, unidad):
        self.tipo = tipo
        self.unidad = unidad
        self.medidas = []

    def registrar_medida(self, valor):
        self.medidas.append(valor)

class VehiculoConSensores(Vehiculo):
    def __init__(self, masa, coef_arrastre, area_frontal):
        super().__init__(masa, coef_arrastre, area_frontal)
        self.sensores = {
            'velocidad': Sensor('Velocidad', 'm/s'),
            'aceleracion': Sensor('Aceleración', 'm/s²'),
            'posicion': Sensor('Posición', 'm')
        }

    def actualizar_movimiento(self, fuerza, tiempo, delta_t):
        for t in np.arange(0, tiempo, delta_t):
            resistencia = self.calcular_resistencia(self.velocidad)
            aceleracion = (fuerza - resistencia) / self.masa
            self.velocidad += aceleracion * delta_t
            self.posicion += self.velocidad * delta_t

            self.sensores['velocidad'].registrar_medida(self.velocidad)
            self.sensores['aceleracion'].registrar_medida(aceleracion)
            self.sensores['posicion'].registrar_medida(self.posicion)

        return self.sensores

vehiculo_sensores = VehiculoConSensores(masa, coef_arrastre, area_frontal)
sensores = vehiculo_sensores.actualizar_movimiento(fuerza, tiempo, delta_t)

# Gráfico de resultados con sensores
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(np.arange(0, tiempo, delta_t), sensores['posicion'].medidas, label='Posición (m)')
plt.ylabel('Posición (m)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(np.arange(0, tiempo, delta_t), sensores['velocidad'].medidas, label='Velocidad (m/s)', linestyle='--')
plt.ylabel('Velocidad (m/s)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(np.arange(0, tiempo, delta_t), sensores['aceleracion'].medidas, label='Aceleración (m/s²)', linestyle=':')
plt.xlabel('Tiempo (s)')
plt.ylabel('Aceleración (m/s²)')
plt.legend()

plt.tight_layout()
plt.show()


import numpy as np
import matplotlib.pyplot as plt

class Vehiculo:
    def __init__(self, masa, coef_arrastre, area_frontal):
        self.masa = masa
        self.coef_arrastre = coef_arrastre
        self.area_frontal = area_frontal
        self.velocidad = 0
        self.posicion = 0

    def calcular_resistencia(self, velocidad):
        densidad_aire = 1.225  # kg/m³
        resistencia_aerodinamica = 0.5 * densidad_aire * self.coef_arrastre * self.area_frontal * velocidad**2
        friccion = 0.01 * self.masa * 9.81  # Suponiendo un coeficiente de fricción de 0.01
        return resistencia_aerodinamica + friccion

    def actualizar_movimiento(self, fuerza, tiempo, delta_t):
        aceleraciones = []
        velocidades = []
        posiciones = []

        for t in np.arange(0, tiempo, delta_t):
            resistencia = self.calcular_resistencia(self.velocidad)
            aceleracion = (fuerza - resistencia) / self.masa
            self.velocidad += aceleracion * delta_t
            self.posicion += self.velocidad * delta_t

            aceleraciones.append(aceleracion)
            velocidades.append(self.velocidad)
            posiciones.append(self.posicion)

        return aceleraciones, velocidades, posiciones

# Parámetros del vehículo
masa = 1500  # kg
coef_arrastre = 0.3
area_frontal = 2.2  # m²
fuerza = 5000  # N
tiempo = 10  # s
delta_t = 0.1  # Intervalo de tiempo

vehiculo = Vehiculo(masa, coef_arrastre, area_frontal)
aceleraciones, velocidades, posiciones = vehiculo.actualizar_movimiento(fuerza, tiempo, delta_t)

# Gráfico de resultados
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(np.arange(0, tiempo, delta_t), posiciones, label='Posición (m)')
plt.ylabel('Posición (m)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(np.arange(0, tiempo, delta_t), velocidades, label='Velocidad (m/s)', linestyle='--')
plt.ylabel('Velocidad (m/s)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(np.arange(0, tiempo, delta_t), aceleraciones, label='Aceleración (m/s²)', linestyle=':')
plt.xlabel('Tiempo (s)')
plt.ylabel('Aceleración (m/s²)')
plt.legend()

plt.tight_layout()
plt.show()


def capturar_gases(self, cantidad_gases):
    capturados = min(cantidad_gases, self.intensidad_magnetica)
    self.gases_contaminantes += capturados
    return cantidad_gases - capturados

def purificar_gases(self):
    purificados = self.gases_contaminantes * 0.9  # asumiendo 90% de eficiencia
    self.gases_purificados += purificados
    self.gases_contaminantes -= purificados


import matplotlib.pyplot as plt

def calcular_eficiencia_trocula(num_poleas, fuerza_aplicada):
    fuerza_necesaria = fuerza_aplicada / num_poleas
    return fuerza_necesaria

def graficar_trocula(num_poleas, fuerza_aplicada):
    fuerza_necesaria = calcular_eficiencia_trocula(num_poleas, fuerza_aplicada)
    
    plt.figure(figsize=(10, 5))
    poleas = range(1, num_poleas + 1)
    fuerzas = [fuerza_aplicada / p for p in poleas]
    
    plt.plot(poleas, fuerzas, marker='o', linestyle='-', color='b', label='Fuerza Necesaria')
    plt.axhline(y=fuerza_aplicada, color='r', linestyle='--', label='Fuerza Aplicada')
    plt.xlabel('Número de Poleas')
    plt.ylabel('Fuerza (N)')
    plt.title('Eficiencia de la Trócula (Polea Compuesta)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parámetros
num_poleas = 6
fuerza_aplicada = 1000  # N

# Graficar Trócula
graficar_trocula(num_poleas, fuerza_aplicada)


import matplotlib.pyplot as plt

def calcular_eficiencia_polipasto(num_poleas_fijas, num_poleas_moviles, fuerza_aplicada):
    fuerza_necesaria = fuerza_aplicada / (num_poleas_fijas + num_poleas_moviles)
    return fuerza_necesaria

def graficar_polipasto(num_poleas_fijas, num_poleas_moviles, fuerza_aplicada):
    fuerza_necesaria = calcular_eficiencia_polipasto(num_poleas_fijas, num_poleas_moviles, fuerza_aplicada)
    
    plt.figure(figsize=(10, 5))
    poleas = range(1, num_poleas_fijas + num_poleas_moviles + 1)
    fuerzas = [fuerza_aplicada / (num_poleas_fijas + p) for p in range(1, num_poleas_moviles + 1)]
    
    plt.plot(poleas, fuerzas, marker='o', linestyle='-', color='b', label='Fuerza Necesaria')
    plt.axhline(y=fuerza_aplicada, color='r', linestyle='--', label='Fuerza Aplicada')
    plt.xlabel('Número de Poleas (Fijas + Móviles)')
    plt.ylabel('Fuerza (N)')
    plt.title('Eficiencia del Polipasto')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parámetros
num_poleas_fijas = 3
num_poleas_moviles = 3
fuerza_aplicada = 1000  # N

# Graficar Polipasto
graficar_polipasto(num_poleas_fijas, num_poleas_moviles, fuerza_aplicada)


import numpy as np
import matplotlib.pyplot as plt

def calcular_potencia_necesaria(resistencia, altura, longitud):
    # Calcula la potencia necesaria basada en la resistencia, altura y longitud del plano inclinado
    potencia = resistencia * (altura / longitud)
    return potencia

# Datos de ejemplo
resistencias = [100, 200, 300, 400, 500]
alturas = [10, 20, 30, 40, 50]
longitudes = [20, 40, 60, 80, 100]

# Calcular la potencia necesaria para diferentes resistencias y longitudes de plano
potencias_necesarias = [calcular_potencia_necesaria(r, h, l) for r, h, l in zip(resistencias, alturas, longitudes)]

# Graficar los resultados
plt.figure(figsize=(12, 8))
for i, resistencia in enumerate(resistencias):
    potencias = [calcular_potencia_necesaria(resistencia, h, l) for h, l in zip(alturas, longitudes)]
    plt.plot(longitudes, potencias, marker='o', linestyle='-', label=f'Resistencia {resistencia} N')

plt.xlabel('Longitud del Plano Inclinado (L)')
plt.ylabel('Potencia Necesaria (P)')
plt.title('Potencia Necesaria para Diferentes Resistencias y Longitudes de Plano Inclinado')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class Vehiculo:
    def __init__(self, masa, coef_arrastre, area_frontal):
        self.masa = masa
        self.coef_arrastre = coef_arrastre
        self.area_frontal = area_frontal
        self.velocidad = 0
        self.posicion = 0

    def calcular_resistencia(self, velocidad):
        densidad_aire = 1.225  # kg/m³
        resistencia_aerodinamica = 0.5 * densidad_aire * self.coef_arrastre * self.area_frontal * velocidad**2
        friccion = 0.01 * self.masa * 9.81  # Suponiendo un coeficiente de fricción de 0.01
        return resistencia_aerodinamica + friccion

    def actualizar_movimiento(self, fuerza, tiempo, delta_t):
        aceleraciones = []
        velocidades = []
        posiciones = []

        for t in np.arange(0, tiempo, delta_t):
            resistencia = self.calcular_resistencia(self.velocidad)
            aceleracion = (fuerza - resistencia) / self.masa
            self.velocidad += aceleracion * delta_t
            self.posicion += self.velocidad * delta_t

            aceleraciones.append(aceleracion)
            velocidades.append(self.velocidad)
            posiciones.append(self.posicion)

        return aceleraciones, velocidades, posiciones

# Parámetros del vehículo
masa = 1500  # kg
coef_arrastre = 0.3
area_frontal = 2.2  # m²
fuerza = 5000  # N
tiempo = 10  # s
delta_t = 0.1  # Intervalo de tiempo

vehiculo = Vehiculo(masa, coef_arrastre, area_frontal)
aceleraciones, velocidades, posiciones = vehiculo.actualizar_movimiento(fuerza, tiempo, delta_t)

# Gráfico de resultados
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(np.arange(0, tiempo, delta_t), posiciones, label='Posición (m)')
plt.ylabel('Posición (m)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(np.arange(0, tiempo, delta_t), velocidades, label='Velocidad (m/s)', linestyle='--')
plt.ylabel('Velocidad (m/s)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(np.arange(0, tiempo, delta_t), aceleraciones, label='Aceleración (m/s²)', linestyle=':')
plt.xlabel('Tiempo (s)')
plt.ylabel('Aceleración (m/s²)')
plt.legend()

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class Vehiculo:
    def __init__(self, masa, coef_arrastre, area_frontal):
        self.masa = masa
        self.coef_arrastre = coef_arrastre
        self.area_frontal = area_frontal
        self.velocidad = 0
        self.posicion = 0

    def calcular_resistencia(self, velocidad):
        densidad_aire = 1.225  # kg/m³
        resistencia_aerodinamica = 0.5 * densidad_aire * self.coef_arrastre * self.area_frontal * velocidad**2
        friccion = 0.01 * self.masa * 9.81  # Suponiendo un coeficiente de fricción de 0.01
        return resistencia_aerodinamica + friccion

    def actualizar_movimiento(self, fuerza, tiempo, delta_t):
        aceleraciones = []
        velocidades = []
        posiciones = []

        for t in np.arange(0, tiempo, delta_t):
            resistencia = self.calcular_resistencia(self.velocidad)
            aceleracion = (fuerza - resistencia) / self.masa
            self.velocidad += aceleracion * delta_t
            self.posicion += self.velocidad * delta_t

            aceleraciones.append(aceleracion)
            velocidades.append(self.velocidad)
            posiciones.append(self.posicion)

        return aceleraciones, velocidades, posiciones

# Parámetros del vehículo
masa = 1500  # kg
coef_arrastre = 0.3
area_frontal = 2.2  # m²
fuerza = 5000  # N
tiempo = 10  # s
delta_t = 0.1  # Intervalo de tiempo

vehiculo = Vehiculo(masa, coef_arrastre, area_frontal)
aceleraciones, velocidades, posiciones = vehiculo.actualizar_movimiento(fuerza, tiempo, delta_t)

# Gráfico de resultados
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(np.arange(0, tiempo, delta_t), posiciones, label='Posición (m)')
plt.ylabel('Posición (m)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(np.arange(0, tiempo, delta_t), velocidades, label='Velocidad (m/s)', linestyle='--')
plt.ylabel('Velocidad (m/s)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(np.arange(0, tiempo, delta_t), aceleraciones, label='Aceleración (m/s²)', linestyle=':')
plt.xlabel('Tiempo (s)')
plt.ylabel('Aceleración (m/s²)')
plt.legend()

plt.tight_layout()
plt.show()

